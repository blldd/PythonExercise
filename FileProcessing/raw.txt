 
 
基于用户行为模式特征的时间序列异常检测
 

 
 1  
绪
   
论
 
1 
 
1  
绪
   
论
 
 
1.1  
时间序列中的异常
 
时间序列记录了现象随时间变化而产生的有序数据。这类数据通常按照等间隔
时间区间进行观测得到。时间序列中的异常点（
Anomalies
）是指某些时间区间对
现象的观测值与其他时刻的数据规律不符。这里其他时刻的数据规律通常是指正
常模式，因此时间序列中的异常点又被称作为与正常模式不相同的点。通常异常
点是在某种情境下受用户（泛指产生数据的主体，如系统，人等）异常行为的影
响而产生的。例如流量工程中，网络流量受到 
Do S 
攻击产生大量的异常流量；推
荐系统中，目标项目受到托攻击被注入大量的虚假评分等。不同的领域中异常也
被称作为离群点（
Outliers
）、不一致点（
Discordant observations
）、例外（
Exceptions
）、
畸变（
Aberrations
）、意外（
Surprises
）、怪癖（
Peculiarties
）和污染（
Contaminants
）
[1]
。其中较常使用的概念有异常点和离群点。
 
不同领域中时间序列的异常产生的原因并不相同，但可以对异常产生的主要的
原因进行总结
[1]
：
 
①
  
数据收集时产生的误差（
Errors
）。通常在测量，操作，计算时产生。这类
由人工（有意或者无意的）过失产生的异常数据通常需要在预处理阶段检测出来，
以避免其对后续研究造成影响。例如对某地区每日温度的收集中出现数据 
100
℃，
则明显是个错误。
 
②
  
数据内部结构的变化。各类因素都可能导致时间序列的内部结构产生变
化。以异常行为为例，系统宕机，网络入侵，金融诈骗等都会导致序列产生变化。
有些变化可以直接反应在数据的统计分布中。以广泛使用的正态分布（
Normal 
distribution
）为例，存在 
0.26%
的数据在离均值的三倍标准差范围之外。这类数据
不常出现，但是是合法存在的，能影响到对数据整体的评价（如均值，方差）。这
类数据通常隐含着特殊信息。
 
由于异常的数目比较少，其携带的信息更具有价值。对时间序列进行异常检
测，根据检测结果分析异常产生的原因和造成的后果，制定策略消除异常或者减
小异常的不利影响是决策系统的主要任务之一。以流量工程中的流量时间序列和
推荐系统中项目的评分时间序列为例：
 
①
  
网络监测中，通过对流量时间序列的检测，发现流量异常的点或序列，寻
找发生变化的（或者受到攻击）的节点或者链路，及时向系统预警；同时改变路
由策略，调整资源分配，以避免网络拥塞。
 
②
  
推荐系统中，通过对项目的评分时间序列的检测，发现虚假评分，有助于重庆大学博士学位论文 
2 
虚假用户的检测；同时系统根据检测出的虚假评分调整相似性计算策略或者推荐
策略，尽可能的产生公平精确的推荐效果。
 
除了上述两项实际应用之外，时间序列还广泛存在于各类领域，如医学中患
者的心电图时间序列，金融学中的金融交易时间序列等。对时间序列的异常检测，
可以为相应领域的决策提供支持。
 
不同应用的时间序列具有不同的特征，故对时间序列的异常检测应当考虑到具
体的应用领域中。本文从用户行为模式的角度，对流量工程中的流量时间序列和
推荐系统中项目的评分时间序列分别进行异常检测，并对各应用中异常检测常见
的问题进行了深入的分析研究与实验验证。
  
 
1.2  
流量工程中流量时间序列的异常检测的研究现状
 
  
直观来说，网络流量的异常可以被定义为有意或者无意的网络攻击、错误、过
失等与正常网络行为相违背的行为
[2]
。其产生的原因有系统宕机，网络路由等设备
配置变化，分布式拒绝服务（
Distributed denial of service
，
DDo S
）攻击等
[3-5]
。近
年来，由于网络规模越来越庞大，复杂度越来越高，网络流量中出现的异常数量
不断增加，种类不断增多。因此有必要对流量时间序列进行深入研究以有效的进
行异常检测。
 
  
网络管理中的入侵检测系统大都包含有已有异常的特征库，通过对新数据进行
特征匹配，判断其是否属于异常
[6]
。这样的系统对于由已知攻击类型产生的异常流
量具有较好的检测效果，然而在检测“变异
”
或者未知的异常类型方面效果不好（检
测精度低，误检率高）
[7]
。因此当前的研究主要集中在对异常流量的检测上。该类
检测寻找与用户（或网络）正常行为模式不匹配的流量数据，并检测其为异常。
常用的方法包括基于已知数据建模的异常检测和基于“未知”数据预测的异常检
测。
 
1.2.1  
基于模型的异常检测
 
基于正常行为模式的异常检测算法利用历史流量构建正常的流量区域，并将不
在这个区域范围内的点判断为异常点。这个问题可以被看作投影问题，判断流量
是否能投影到正常流量空间，将无法投影到正常流量空间的点视为异常点。如下
图 
1.1 
所示。
 1  
绪
   
论
 
3 
 
图 
1.1  
网络流量异常检测问题的简化描述。假设存在由正常行为模式产生的“正常流量（
Typical 
traffic
）”空间，τ，存在于由所有流量信号产生的更大的空间，Ω。基于正常行为模式的异常
检测方法从历史数据中评估区域τ，并得到τ的近似 
ˆ
 
。利用 
ˆ
 
判定流量是否能投影到正常
空间，若有较大的误差，则为异常流量。由于 
ˆ
 
是τ的近似，故判定过程会产生两种错误类
型：漏检项和误检项。
 
Fig.1.1 A simplified picture of anomaly detection in network traffic. Conceptually, there is a space of 
traffic signals which are “typical”, τ, within the larger space of all traffic signals, Ω. We seek to 
estimate this region from historical data, and approximate it by  
ˆ
 
, so that we can classify new 
signals. Inaccuracies in the approximation result in errors of the two types indicated: missed 
detections and false alarms. 
 
  
实际应用中产生的流量时间序列规模较大。如果异常检测的算法误检率较高，
会有大量的流量数据被误认为是异常流量，进而需要耗费大量的人力和物力对判
断结果进行人工甄别和后续处理。因此异常检测模型必须有很低的误检率（至少
在 
10
-4
以内）
[8]
。当前技术利用历史数据产生的函数作为基（
Basis
）表示正常网络
流量。但由于本身携带信息的不足，大多数方法都无法获得如此低的误检率。事
实上，基于历史数据对正常网络流量建模，构建空间 
ˆ
 
，在拟合新数据时，可能会
在数据投影时产生较大的误差，导致建模不准确，也可能会出现投影误差太小，
并导致过拟合的情况。
 
因此大多数方法进行异常检测都面临两大问题：精确的评估和泛化。本质上来
说这些方法都面临着究竟使用多少基函数构建正常流量空间τ的问题。基函数太
少可能会导致 
ˆ
 
和τ之间的误差太大，进而无法对新数据进行准确判断。使用更多
的基函数可能会产生局部 
ˆ
 
更加贴近τ，然而这违背了奥坎姆剃刀（
Occam’s razor
）
原则，即特征数目越少越好
[9]
。同时也可能会引发过拟合现象。基函数的数目越多，
则其构建的空间 
ˆ
 
对历史数据能进行更好的拟合，然而新的数据投影到 
ˆ
 
时，需要
评估更多的参数值，且更容易被误分。这是因为过多的基函数可能拟合了历史数
据中的“噪声”，这种过拟合现象导致了模型的泛化能力变弱。因此在选择表征空
间τ的基函数时，要对基函数的数目做出权衡（
Tradeoff
）。合适数目的基函数可重庆大学博士学位论文 
4 
以更好的拟合正常流量空间。
 
  
主要的流量检测技术的流程为如图 
1.2 
所示。通常在正式处理问题之前要对输
入数据做一次转换，例如计算流量数据中部分属性的熵（
Entropy
）和互信息量
（
Mutual information
）
[5, 10, 11]
，去除均值或中值实现数据的去中心化
[12, 13]
等。
 
 
 
图 
1.2  
网络流量异常检测的通用流程。数据变换是预处理过程。基函数生成过程利用历史数
据选择合适的基函数。数据重构过程利用生成的基函数拟合新数据。异常检测根据新数据与
利用基函数拟合的数据的误差对异常进行检测。
 
Fig. 1.2 The general anomaly detection process. “Data transformation” is a preprocessing procedure. 
“Basis derivation” generates a basis from the historical data. “Data reconstruction” approximates the 
new data with the basis. “Anomaly detection” detects anomalies from the residual series, which 
records the difference between the new data and its approximation. 
 
当前对网络流量进行异常检测的方法包括 
Fourier 
分析
[14]
，小波分析
[15]
，主成
分分析（
Principal component analysis
，
PCA
）
[13, 16]
，
ANNs
[6]
，以及 
Basis Detect
[17]
等。对基函数的权衡在上述这些技术中广泛存在。例如在对数据做 
Fourier 
分析中，
常过滤信号的低频部分，将剩余的高频信号看作异常，或者利用低通滤波器对信
号进行拟合，进而对残差进行检测以发现异常成分。这里需要均衡的是看作低频
的频率数目。大量的低频会产生很好的拟合，但是某种程度上也对噪声进行了拟
合。 
  PCA 
方法将高维数据转换到低维空间中，将投影在低维空间的主成份看作是
正常流量数据，对剩余的非主成份的流量进行检测发现异常。其中低维空间的维
数需要做均衡，特别是在含噪声较多的数据中，过少的维数会丢失正常数据的特
征，而过多的维数会导致作为正常数据的主成分部分包含异常点
[18]
。
PCA 
是从无
限空间中选择特征向量作为基函数用于流量表示。
PCA 
假设流量数据是独立同分
布的，且满足高斯分布。但是这与网络流量数据的情况不符合。真实情况下网络
流量具有长相关性和周期性，即数据内部是有相互关系的。
 
  
当流量包含大量的异常类型时，经典的 
PCA 
算法已经无法有效的找出正常流
量的主成分。此时通过寻找“主方向
”
，使流量序列在该方向的投影与中心点（通
常为中值）的距离最大，可以得到对异常点不敏感的正常空间的特征向量。这种1  
绪
   
论
 
5 
求解主成分的算法叫做 
RPCA
（
Robust  PCA
）算法
[19]
。另外一种减弱异常对正常
数据结构影响的算法是 
Iterative PCA
[20]
。该算法认为最大的前 
k 
个奇异值对应的特
征向量构成的特征空间为正常流量空间，后续所有奇异值对应的特征向量构成的
特征空间为异常流量空间。以迭代的方式建立异常流量空间，在该空间中寻找异
常可能性最大的流量区间，并移除其对正常流量空间的影响。
 
  
与已有的检测方法不同，
Basis Detect 
采用了不同的解决思路。
Basis Detect 
构建
了包含正常行为模式特征和异常行为模式特征的特征字典，并从中选择合适的基
函数对原始流量进行表示。
Basis Detect 
通过已标记的异常流量数据集获得异常行
为模式下的特征，即以每个异常点为中心的大小固定的一段流量残差序列。如果
Basis Detect 
采用的异常特征集合更大（如使用不同大小的异常流量残差序列作为
特征），用于搜索的特征集合相应的也更大，则用少数的特征即可表示原始流量。
然而更大的特征集合意味着计算规模的增加。
 
  
综上所述，上述几类方法都可以用图 
1.2 
的流程进行表示。假设区域 
ˆ
 
用一组
基函数来描述。由于该区域的形状未知，即可能不是一个标准向量空间，故基并
不完全是数学定义中构成空间的正交基向量。由图 
1.2 
可知各技术对流量的异常检
测可以大致分为 
4 
个步骤：数据转换，基函数生成，数据重构，异常检测。其中
数据转换是为了凸出异常行为对流量造成的影响。基函数生成是设计算法从特征
空间中发现合适的基函数，并用其表示 
ˆ
 
，使 
ˆ
 
和τ最接近。数据重构是指在 
ˆ
 
空
间中对原始流量数据进行重构。异常检测是指对重构误差进行假设检验以判断异
常点。
 
  
上述四种模型从不同的角度实现了对流量的异常检测，表 
1.1 
列举了四种方法
在特征空间和基函数生成方面的不同。
 重庆大学博士学位论文 
6 
表 
1.1 
四种模型在备选解空间和搜寻最优基函数方面的比较。利用算法从备选解空间中搜寻一
组合适的用于近似
”
标准流量
”
空间τ的基。基函数生成方式是指用于搜寻合适基的算法。基大
小是指用于精确表示历史数据的基的个数。
 
Table 1.1 Comparison of anomaly detection in terms of candidate basis functions and techniques of 
finding a representation for a given data set. Here, the candidate solution space describes the set of 
functions from which we can construct a typical traffic signal; and the No. is the 
number of functions in this space for a signal of length n. The basis derivation refers to the technique 
used to refine this to a basis for the typical traffic. The basis size is the number of functions then 
required to accurately represent the historical traffic. 
方法
  
备选解空间
  
解空间大小
  
基函数生成方式
  
基大小
 
Fourier  
正弦函数
  n  
由低频函数决定
  
大
 
Wavelet
[15]
  
过完备小波函数
  kn  
软阈值（去噪）
  
大
 
Basis Detect
[17]
 
过完备字典（包含
正余弦或小波函
数，以及异常流量
序列）
 
kn  
改进版的 
OMP 
算法
  
中等
 
PCA
[11]
  
任意
  
∞
  
特征分析
  
小
 
 
1.2.2  
基于预测的异常检测
 
网络流量预测是根据历史数据对未来网络流量进行估计。预测的结果可用于网
络设计，流量工程和网络管理中。例如，流量预测能够突出未来数月或数年网络
流量的变化，便于设计网络。而毫秒级或者分钟级的流量预测有助于系统实时动
态分配网络路由器或者带宽等网络资源
[21,  22]
，以及节能。网络流量预测也可以用
于异常检测中。因此精确有效的对网络流量进行预测在流量工程中具有很重要的
意义
[23]
。
 
早期关于流量序列的研究是建立在其具有广义范围平稳性的基础上，因此基于
ARMA
（以及其优化版本 
ARIMA 
等）的预测算法适用于流量预测
[24-26]
。然而网络
流量的急剧变化导致上述模型无法描述当前网络流量的特性，在实时流量预测中
也失去了有效性。当前常用的方法有将 
ARIMA 
模型与各类方法结合来处理越来越
复杂的网络流量；或者基于 
ANNs 
的预测算法在处理非线性时间序列上具有优越
的特性
[27]
，将其用于网络流量的建模和预测中。
 
ARIMA 
通常与信号处理的方法结合在一起。基于小波的 
ARIMA 
模型可通过
小波对流量进行分解得到平稳特征序列，并利用 
ARIMA 
对其进行建模预测
[28]
；
基于分形的 
ARIMA 
模型可以在长时和短时两个尺度对网络流量进行表示，并预测1  
绪
   
论
 
7 
未来网络流量
[29]
。然而基于分形的算法具有很高的复杂性，实际应用中，利用分
形布朗运动模型（
Fractal brown motion
，
FBM
）将其应用于实时流量仿真中，其所
用的参数更少，复杂度更低
[30, 31]
。然而基于 
FBM 
的模型只能刻画网络流量的长时
相关性。
 
ANNs 
通过对历史数据的学习在毫秒级或者分钟级的实时预测上具有高精度。
然而这类算法的“黑盒子”特征导致无法对预测结果给出合理的解释。同时它们
要求大量的训练时间来优化参数和调整结构。例如，广泛应用的 
BP 
神经网络模型
在训练过程中收敛速度很慢，导致其训练时间特别长，因此其并不适用于实时处
理中。文献
[32]
对其传递函数进行改进，不仅加快了训练速度还提高了预测进度。
基于共变正交的 
ANNs 
模型在处理高突发性网络流量时具有更多的优势
[33]
。而对
于 
ANNs 
本身结构的改造通常是基于智能优化算法，例如文献
[21]
中通过跨层连接
简化网络结构，并利用粒子群优化算法选择合适的输入变量对 
ANNs 
的网络结构
进行改造；或者基于剪枝的方法
[34]
对结构进行优化，即通过节点输出与其他节点
的相关性程度判断该节点是否有存在的必要。由于 
ANNs 
基于梯度下降的学习算
法易陷入局部最优，因此常采用智能优化算法使 
ANNs 
在参数确定的过程中能避
免局部最优解，得到更加合适的全局最优解
[21,34-36]
。
 
 
1.3  
推荐系统中项目的评分时间序列异常检测的研究现状 
在线资源（包含信息和商品）的爆炸式增长为人们在网络活动中提供了大量的
选择，尽管通过信息检索技术已经做了大量的过滤，用户依然面临大量的选择，
而这些选择很多都是不必要的
[37]
。个性化推荐技术，特别是协同过滤推荐
（
Collaborative filtering recommendation
，
CF
）已经成功用于过滤不必要的信息
[38-40]
，且被广泛用于各类领域，如辅助教学，在线学习
,
电影电视节目，旅游，在
线社交网络以及数字图书馆等。
 
CF 
系统依赖于对项目的评价信息（通常以评分的形式），因此对托攻击非常的
敏感
[41-43]
。托攻击是指设计一类用户对项目进行虚假评分使部分项目被推荐的概
率升高或者降低，使攻击者从中受益
[41-44]
。通常项目提供者可能会注入大量的高
分来提高项目的口碑或者对竞争项目注入低分来降低其被推荐的概率。由于托攻
击产生了大量无用甚至误导人的信息，对推荐结果产生重要的影响，因此托攻击
被认为是 
CF 
系统的重要威胁。
 
通常基于虚假用户的特征来检测托攻击，然而这样通过提取特定攻击的特征产
生的模型将受限于具体的攻击类型
[41, 44, 45]
。当前已有的技术只能用于检测异常的
用户，而不是异常的行为，这导致存在一些正常用户因为其部分评分行为而被误
认为是异常用户的现象
[46]
。例如一些真实但是比较挑剔的用户可能因为在某项目重庆大学博士学位论文 
8 
（该项目总体评价很高，大众对其很满意）上评分太低而被检测为虚假用户。
 
根据攻击的意图，托攻击可以分为两种类型：推攻击（
Push attacks
）和核攻击
（
Nuke attacks
）
[41, 44]
。意图提高项目声誉的攻击叫做推攻击，而意图降低项目声
誉的攻击叫做核攻击。
Ihsan Gunes 
等
[44]
基于 
B. Mobasher 
等人
[41]
的工作总结了常
用的几类托攻击类型，如表 
1.1 
所示。由于采用了相同的攻击策略，我们将流行攻
击和反流行攻击放在一起比较。
I
S
是被选中的与目标项目有关系的一组项目，
I
F 
是
随机选中的填充项目，
i
t 
是要注入虚假评分的目标项目。要注入的虚假评分为 
r
max
（用于推攻击），或者 
r
min
  
（用户核攻击）。剩余未评分的项目为 
I
Φ
。
  
 
表 
1.1  
托攻击类型的总结。
r
max
是最高评分
, r
min
是最低评分。
 
Table 1.1 Attack profile summary. r
max 
is the maximum rating, r
min 
is the minimum rating. 
类型
 
随机
（
Random
）
 
均值
（
Average
）
 
探查（
Probe 
/informed
）
 
流行
/
反流行
（
Bandwagon/revere 
bandwagon
）
 
S
I
 
Not used 
(NU) 
NU 
RC; system 
response 
Popular/unpopu
lar items; r
max
 
F
I
 
Randomly 
chose (RC); 
system mean 
(SM) 
RC; item 
mean (IM) 
Seed items; 
true preferences 
RC; SM 
φ
I
 
F
I 

I
 
F
I 

I
 
F S
I-{I 

I }
 
F S
I-{I 

I }
 
t
i
 
r
max
/r
min
  r
max
/r
min
  r
max
/r
min
  r
max
/r
min
 
类型
 
段
（
Segment
）
 
爱恨
（
Love/hate
）
 
混合
（
Hybrid
）
 
一致
（
Consistency
）
 
S
I
 
Segmented 
items; r
max
 
NU 
Popular/kno
wn average 
items; r
max
/item 
average 
Favorite items 
of a user; r
max
 
F
I
 
RC; r
min
  RC; r
max
  RC; SM  
S
I 

I
; Random 
φ
I
 
F S
I-{I 

I }
 
F S
I-{I 

I }
 
F S
I-{I 

I }
 
φ
 
t
i
 
r
max
  r
max
/r
min
  r
max
/r
min
  r
max
/r
min
 
 
除了上述攻击类型，学者还提出了其他的攻击类型，可以躲避当前大多数检测
器的检查
[47]
，例如模糊攻击（
Obfuscated attacks
）
[48]
,  
基于流行项目的均值攻击
（
Average over popular items
，
Ao P
）
[49]
。
 1  
绪
   
论
 
9 
一种减少托攻击影响的方式是增强推荐算法的鲁棒性。通常 
CF 
算法通过结合
语义信息
[41]
，或用户或项目的信任和信誉度信息
[50]
等提高推荐的可靠性。这类信
任和信誉值可以通过贝叶斯推理
[51, 52]
，可信度传播和因子分解
[53, 54]
的方式得到。
然而这类方法使我们无法从中得到异常评分的信息，因此更多的学者专注于虚假
用户和被攻击项目的检测。
 
基于用户异常检测通过学习算法将虚假用户从真实用户中分离出来，常用的学
习算法包括监督式，半监督式和无监督式。监督式学习中常用的特征有 
Rating 
deviation from mean agreement
（
RDMA
），
Weighted degree of agreement
（
WDA
），
Filler mean target difference
（
FMTD
），
Target model focus
（
TMF
）
[55]
等。文献
[44]
将其总结为三类特征：一般特征（
Generic attributes
），模型特征（
Model attributes
），
概貌内特征（
Intraprofile attributes
）。上述特征都可用于半监督式学习中对未标记
的用户概貌的学习
[56, 57]
。无监督式方法包含聚类，
PCA 
等方法。其中文献
[58]
针对
最具有伪装性的模糊攻击类型，提出了一种基于统计特征（概貌之间的协方差）
的无监督检测算法，具有较高的检测精度和较低的误检率。此外，
Zhang 
等
[59]
从用
户评分特征的角度提出虚假用户之间的相关度非常大，因此将对虚假用户检测的
问题转化为从用户的相似度矩阵中提取相关度非常大的子矩阵问题。该算法属于
NP 
难问题，可以通过启发式图算法进行求解。与其他基于用户的托攻击检测算法
相比，该方法具有更优的检测效果。由于虚假用户可以伪装为正常用户，而正常
用户也存在可疑概貌的情况，因此基于用户概貌的托攻击检测难度比较高
[45, 46, 60]
。
 
基于项目的异常检测主要是对项目的异常评分的检测。常用基于统计的异常检
测方法，其中 
X-bar 
算法
[61]
依赖两种统计控制的方法进行异常检测：
X-bar 
控制限
制以及区间置信度限制。如果一个项目的均值在设定的置信度之外，则被认为是
异常的。类似的 
Zhang 
等
[62]
通过量化采样均值和熵的变化对托攻击进行检测。基
于 
chi-square
（

2
）分布的方法通过对不同时间区间内评分分布的比较确定异常的
时间区间，进而确定相应的异常项目
[63]
。许多基于项目的异常检测方法无法确定
时间区间的大小，在上述方法中，时间区间的大小是依据经验进行划分的，而文
献
[62]
提出了基于启发式的算法来分割时间区间，该算法要求已知异常的长度信息。
Zou 
等
[31]
假设虚假用户对目标项目进行攻击时具有集中性，基于目标项目的信任
因子传播的方法推理出异常用户。
Zhou 
等
[64]
联合用户概貌和目标项目对项目的评
分进行异常检测。该算法首先确定疑似托攻击的用户概貌集合，再根据前述的有
效特征对可疑托攻击用户进行检测。因此，为保证算法的有效性，在确定可疑用
户的阶段包含尽可能多的可疑用户。
 
 重庆大学博士学位论文 
10 
1.4  
本文研究的主要内容和结构
 
1.4.1  
本文的主要研究内容
 
本文基于用户的行为模式，对流量工程中的流量时间序列和推荐系统中项目的
评分序列分别进行异常检测。其中，基于用户正常行为模式对流量工程中的流量
时间序列的特征进行分析，进而实现异常检测；基于用户异常行为模式对推荐系
统中项目的评分时间序列的特征进行分析，进而实现异常检测。本文的工作在国
家 
973 
项目（
2013CB329103
）
“
资源动态适配机制与理论
”
和国家自然科学基金项
目（
71102065
）
“
基于用户可信度的抗托攻击协同过滤推荐机理研究
”
的支持下开展
研究，主要研究内容如下：
 
①
  
基于正常行为模式的流量时间序列异常检测。
 
针对流量工程中项目时间序列的异常检测问题，设计了异常检测模型
Basis Evolution
，包含了数据预处理，基函数生成，基函数更新，异常检测等四个
阶段。
 
1)  
实际应用中，异常产生原因和表现形式的复杂性导致人工很难标记数据。
而大量的用户和应用产生的庞大数据规模更增加了人工分析数据的难度。因此海
量的未标记的数据无法直接为异常检测提供有效信息。
 
数据预处理时，针对异常检测的未标记样本处理的问题，本文借鉴集成学习
的思路，提出多种异常检测算法联合检测的模型。对未标记的流量时间序列，选
取多种类型的异常检测算法进行检测，尽可能的达到 
100%
的检测精度。高检测精
度可能会带来高误检率，因此剔除异常点后，基于预测和周期性插值的方式对异
常点处的真实流量进行评估，以降低高误检率的信息损失。多次迭代上述检测和
插值的过程，尽可能的去除流量时间序列的异常，为后续正常流量空间的构建提
供有效的信息。
 
2)  
对流量时间序列的异常检测需要考虑两大问题：使用的检测算法需要能够
检测“变异
”
或未知的异常类型；同时算法应具有极低的误检率，以保证在实际应
用数据规模极大的前提下，管理员（或系统）无需耗费资源对检测结果进行二次
分析和验证。
 
针对异常检测的普适性和精确性问题，本文设计了基函数生成过程。利用用
户（或网络）的正常行为模式，提出基于周期性奇异值分析（
Single  Value 
Decomposition
，
SVD
）的异常检测算法。该方法基于用户（或网络）的正常行为
模式，分析流量时间序列具有周期性的特征。通过 
SVD 
提取包含周期性特征的特
征向量，构建了正常流量空间。基于周期性 
SVD 
的方法进行异常检测，就是判断
数据是否可以投影到正常流量空间中。由于对正常流量进行建模，可以检测出任
意类型的异常。同时基于 
SVD 
方法提取的基向量是数据能量流动最大的方向，反1  
绪
   
论
 
11 
应了正常流量的结构特征，可以精确的表达正常流量空间，具有较强的异常检测
性能。
 
3)  
实际应用中产生的流量时间序列是不断更新，动态变化的。样本空间的不
完整性使基于静态结构的模型在检测新的流量数据时失效。
 
针对异常检测的动态适应性问题，本文设计了基函数更新过程。利用增量学
习的思路，基于用户（或网络）的正常行为模式统计上缓慢变化的特性，提出对
旧的基函数进行更新的演化算法。该方法将动态适应性问题转化为对旧的基函数
优化的问题，最终得到的新的基函数不仅保持了与历史基函数的相似性，还适应
了新数据的特征，因此具有较强的异常检测性能。此外，以演化的方式更新基函
数，降低了计算规模，缩短了计算时间。
 
4)  
实际应用中的流量时间序列规模非常庞大，即使具有极高精确度和极低误
检率的异常检测算法都会检测出大量的异常点。管理员（或系统）需要耗费大量
的资源逐个对异常点进行分析，以及时提供决策结果。
 
针对异常点分析的问题，在异常处理阶段提出对异常点的聚类算法以降低管
理员（或系统）对异常点的分析规模。由相同异常触发的异常点具有时间集中性，
因此认为时间上集中出现的异常点是由相同异常产生的。对异常点的聚类算法将
时间上距离较近的异常聚为一类。管理员（或系统）在分析时只需要对类进行分
析，而无需对每个异常点进行分析，大大降低了工作量，减少了工作时间。
 
②
  
基于趋势预测的时间序列异常检测。
 
网络流量的时间序列中，基于流量时间序列的预测可以在线的实现异常流量
检测。然而有效预测模型的构建需要大量的训练时间。针对 
ANNs 
预测模型中存
在的上述时间效率的问题，提出基于趋势预测的异常检测方法。该方法基于用户
（或网络）的正常行为模式，分析流量时间序列具有周期性和短时相关性的特征。
通过对包含上述特征的流量成分（趋势）的预测，实现对未来正常流量的评估。
基于预测的方法进行异常检测，就是判断未来流量的实际值与预测值是否一致。
与经典的 
ANNs 
模型相比，基于趋势的预测模型，对原始大量的训练样本进行变
换，减少了直接用于训练的样本数，在较短的训练时间内即可得到精度较高的预
测模型。因而在异常检测中，基于趋势的预测模型具有更优的检测效果。
 
③
  
基于异常行为模式的时间序列异常检测
 
针对推荐系统中项目的评分时间序列异常检测问题，分析托攻击的异常评分
特征，并提出项目评分时间序列的异常检测模型 
SDF
。针对特征提取和异常检测
中的问题，分别提出相应的解决办法。此外，针对异常检测模型结果不一致的问
题，提出稳定性的评价标准。
 
1
）异常检测模型 
SDF
：
 重庆大学博士学位论文 
12 
a.
推荐系统中，托攻击通过制造虚假用户概貌将自己伪装为正常用户，而正常
用户的评分序列中存在可疑的评分行为。这一现象导致很难从用户的角度分析其
异常行为模式，进而难以提取特征判断正常行为的评分数据与托攻击行为的评分
数据。
 
针对异常特征提取的问题，提出从目标项目的角度分析用户的异常行为模式。
由于托攻击通过添加对目标项目的评分改变其被推荐的概率，因此根据目标项目
的评分时间序列可以对异常评分的情境属性和行为属性进行分析。基于目标项目
的异常评分属性，提取当前所有托攻击类型中评分的特征，具有普适性和可扩展
性。
 
b.
在线应用中，要求系统能实时有效的提供异常检测结果，以便于及时调整策
略，作出最优决策。
 
针对异常检测的实时性问题，提出一种普适的动态分割项目的评分时间序列
的算法。该算法基于异常评分特征，计算各评分对当前分布的贡献，并基于贡献
的一致性对评分聚类。由于异常评分对目标评分分布的贡献类型一致，因此被聚
在同一类。结合统计学的方法（如假设检验）检查每个类是否属于异常，即实现
对评分时间序列的异常检测。与其他基于项目的异常评分检测算法相比，该算法
不仅能够直接使用未标记数据，还能在线的对新样本进行聚类操作和统计检验，
具有更优的检测性能。
 
2
）算法的稳定性准则：
 
推荐系统的项目的评分时间序列中，不同时间尺度下，同一个算法对同一个
数据的异常检测可能产生不同的结果。针对异常检测结果不一致的问题，本文基
于样本完整性和算法稳定性分析其产生的原因，并在具体的应用领域中，讨论了
结果不一致可能产生的影响。同时，本文设计了算法的稳定性指标作为衡量算法
鲁棒性的标准之一。对比常用的几种算法的稳定性发现 
SDF 
的稳定性最优。
 
1.4.2  
本文的主要结构
 
本论文各章的组织安排如下：
 
第一章绪论部分主要介绍了时间序列中异常产生的原因和进行异常检测的意
义。针对本文的研究领域，着重介绍了流量工程中流量时间序列异常检测和推荐
系统中项目的评分时间序列异常检测的研究现状。最后概述了本论文的主要工作
和贡献。
 
第二章基于机器学习分析了时间序列异常检测中常用的算法模型，主要介绍了
基于静态数据结构和动态数据结构的异常检测算法。讨论了各类异常检测算法和
模型的理论基础、算法复杂度、动态适应性以及在部分应用领域的研究现状。
 
第三章基于用户（或网络）的正常行为模式的时间序列异常检测。主要讨论了1  
绪
   
论
 
13 
流量工程中对流量时间序列进行异常检测的模型。着重介绍基于多种异常检测算
法联合的对未标记数据进行清理的预处理方法；包含周期特征，具有可解释性，
并构成正常流量空间的基函数生成方法；能够适应时间序列动态变化的基函数更
新方法；以及对异常点聚类的方法。本章从异常点和异常类两个角度对异常检测
方法的性能进行评估。相比于常用的流量异常检测方法，本章提出的异常检测框
架不仅具有更精确的检测精度和更低的误检率，所聚集的异常类还具有更高的一
致性和聚合性。
 
第四章基于时间序列趋势预测模型的异常检测。主要讨论了包含流量周期特征
和短时相关特征的流量趋势特征提取方法，以及对流量周期趋势，相关趋势和扰
动的预测方法。与通用的 
BP 
神经网络预测算法相比，在更少的训练时间内能取得
更高的预测精度。在异常检测的实验中，本章提出的方法具有更优的检测性能。
 
第五章基于用户异常行为模式的时间序列异常检测。主要讨论了推荐系统中基
于目标项目的异常评分特征；对项目的评分时间序列动态分割的聚类算法；以及
基于结果偏移的算法稳定性评价标准。以其他算法对比的实验表明，本章提出的
异常检测算法在保证精确率的前提下具有更低的误检率，且判定结果具有稳定性。
 
第六章总结本文的研究工作，指出对目前研究的不足之处，解决办法以及未来
的研究方向。
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 重庆大学博士学位论文 
14 
 
 
 
 
 
 
 
 
 
 
 
 
 2  
基于机器学习的时间序列异常检测算法
 
15 
 
2  
基于机器学习的时间序列异常检测算法
 
 
对时间序列的异常检测，主要基于时间序列的情境属性（
Contextual attributes
，
特指数据在时间序列的次序）和行为属性（
Behavior attributes
，特指数据除去情境
属性的其他一切属性）提取有效特征
[65]
；根据特征学习相关规则，并基于规则判
定数据是否异常的过程。通常将对时间序列的异常检测分为基于统计的异常检测、
基于距离的异常检测、基于聚类的异常检测和基于分类的异常检测四类。
 
随着科技的发展和时间序列的广泛应用，各个领域中时间序列的动态变化特性
越来越明显，各应用的决策系统对异常检测结果的实时性要求越来越高。上述四
类异常检测方法大多要求对历史数据进行多次读取以得到精确的判断规则。而实
际应用中，在线时间序列的数据存储结构通常以流的形式存储，即数据不断更新，
且有效期非常短。因此上述四类异常检测方法只能批量地存储流量的时间序列，
并将其作为整体用于学习。对于新数据或者是新的时间序列，利用已有的规则进
行检测。上述四类特征被称作为基于静态结构的时间序列异常检测算法。
 
很明显，基于静态结构的时间序列的异常检测对数据的动态变化适应能力较
弱，可扩展性比较差。由此引入了基于动态结构的学习方法，该方法使用诸如增
量学习或者集成学习的思路，不断更新用于训练的样本数据，使检测模型更适应
于动态变化的在线时间序列中。
 
本章主要从静态结构和动态结构两方面对时间序列异常检测中相关的机器学
习算法进行了研究和分析。
 
 
2.1  
基于静态结构的时间序列异常检测算法
 
2.1.1  
基于统计的时间序列异常检测
 
基于统计的方法分辨正常数据和异常数据的基本假设就是数据满足某个分布，
正常数据落在高概率区域，异常数据落在低概率区域。本方法要求对数据所满足
的分布进行表示。常用的表示方法是基于参数的分布假设方法和基于非参数的概
率分布评估方法。前者常用的假设分布为正态分布，回归模型和混合分布模型。
后者常用的概率分布的评估方法为 
k 
近邻法，直方图法，基于核函数的方法，基
函数展开法和 
copulas 
等方法。由于假设分布的不同，或者采用的概率分布评估方
法的不同，相应的对异常点的判断准则也不相同。
 
①基于参数的分布假设
 
参数化技术中，通过对数据，特别是正常数据的分布进行假设，基于历史数据
（不要求已标记）对分布的参数进行评估，可得到数据的概率密度函数。通常采重庆大学博士学位论文 
16 
用的参数评估算法有最大似然估计（
Maximum  likelihood  estimates
，
MLE
）、贝叶
斯法和
  
期望最大化（
Expectation maximum
，
EM
）算法。
 
若假设的分布为正态分布，采用的参数估计方法为最大似然估计或者贝叶斯
法，可采用置信区间或假设检验的方法对异常进行检测。若假设的分布为回归模
型，可采用信息的丢失程度对异常进行检测。若假设的分布为混合分布模型，可
根据数据点所属的分布进行判断。这里对广泛使用的正态分布和混合分布做简要
介绍。
 
作为使用最广泛的一类分布，正态分布可通过计算新数据与正态分布中估计的
均值之间的距离判断是否为异常数据。若距离超过阈值，则新数据被判断为异常，
反之则为正常。假设正常数据存在于一个范围中，可以采用区间的方式对其进行
估计，这种区间估计又称为置信区间，表示对检测结果的可信程度。最简单的判
断准则为 
3
σ（σ为拟合的正态分布的标准差）准则。若新数据与均值μ的距离大
于 
3
σ，则该数据被判定为异常数据，该结果的置信系数为 
99.7%
[66]
。不断调整置
信系数，可得到不同检验水平下的正常值范围及相应的检测结果。基于置信区间
的异常检测方式由于量化了误差范围而被广泛的应用于时间序列的检测算法中。
 
另外一种方法是通过假设检验来判断异常检测的结果。通过对正常数据的统计
特征进行描述（如均值的范围）设计一个需要被检验的原假设。假设检验的主要
过程为：根据实际应用需求，提出原假设和对立假设；确定显著性水平和样本数；
确定接收域和检验统计量的形式；依据功效函数判断是否接受原假设。
 
异常判断的假设检验过程需要确定数据的分布以及相应的参数，且不同情境下
异常的定义是不同的。针对上述问题，文献
[67]
提出数据的异常分值（
Anomaly score
，
例如 
k 
近邻平均距离）代替数据分布的统计量用作检验统计量；基于模糊集的方
式对正常数据和异常数据的范围设置阈值，并设置空假设为异常分值大于阈值。
通过自适应的检测算法调整假设检验中需要的参数，实现对数据的假设检验。该
算法避免了对数据分布的假设，属于无监督学习。
 
除了上述两种异常检测方法之外，基于数据正态分布的检测方法还有 
Grubb
检测
[68]
，学生 
t 
检测
[69]
，盒图法（
Box plot
）
[70]
，χ
2
（
Chi-square
）检验
[71]
等。
 
对于非正态分布的数据来说，可假设其满足多个分布混合的模型。因此混合模
型可以对一般的分布建模。一种方法假设正常数据和异常数据分别属于相互独立
的两个分布。通过检测新数据满足哪种分布，即可判断该数据是否异常
[72]
。另一
种方法假设正常数据为不同分布的混合。如果新数据不属于任何分布，则判断其
为异常。最常用的混合模型为混合高斯模型（
Guassian mixture model
）
[73]
。该模型
尤其适用于分量类型未知且相互独立的情况。使用混合模型时选择混合分量的数
目是最困难的。
 2  
基于机器学习的时间序列异常检测算法
 
17 
有限混合模型已经被成功用于各类领域中，以流量工程中矩阵的填充为例
[74]
，
基于网络流量的时间稳定性和空间相关性，提出基于混合高斯分布的流量模型，
实现流量矩阵缺失数据的填充。利用经过填充的流量矩阵，对异常流量进行检测。
 
②基于非参数的概率分布评估方法
 
与参数化学习方法不同，非参数化的技术中对数据的分布无需提前进行假设，
因此可能导致相应的概率密度函数不再平滑。而非参数化技术的优势是适用于序
列的分布无法简单假定为含有一组参数的概率分布，这时对于数据所满足的分布
评估完全依赖于已有数据。
 
其基本的异常检测过程为通过对已标记为正常的历史数据的分布情况进行表
示（对概率密度函数进行估计），将无法表示的新数据判定为异常点。通常使用 
k
近邻法，直方图法，基于核函数的方法，基函数展开法和 
copulas 
等方法对数据的
密度函数进行拟合及描述。这里介绍前三种方法。
 
其中最早的密度估计方法是直方图法（
Histogram
）。已经被广泛应用于入侵检
测和金融欺诈检测中
[1]
。其检测过程为在分布函数的坐标轴上划分大小相等的单元
格，基于已标记的正常数据统计单元格内的样本数，计算频率值得到正常样本数
据落在某一范围的密度。计算新数据是否落在单元格内，若不在单元格内，则判
断其为异常数据。该方法中直方图的单元格的大小决定了异常检测的性能。如果
单元格太小，会出现正常的数据落在空的或频率很低的单元格中，被误判断为异
常数据，相应的误检率升高。如果单元格太大，则异常的数据可能落在高频率的
单元格中，相应的检测精度下降。针对这个问题，常用的解决方法是通过直方图
自适应数据的方式解决。在样本数有限的情况下，用直方图的描述符（如大小，
位置，形状等）适应数据，以构造近似数据分布的方法。常通过对直方图的单元
格进行插值，合并或划分的方式对单元格的大小进行调整，使其更加吻合数据的
分布
[72]
。
 
如果要求对密度函数进行平滑估计，最合适的方法为核函数法（
Kernel 
function
）。核函数法又称为密度估计的 
Parzen 
法
[75]
。核函数法固定单元格数目，
基于落入每个单元格内的样本数目估计密度。与上述基于参数的异常检测过程类
似，通过已有数据拟合概率分布，若新数据被判定为不属于该分布，则被判定为
异常。核函数法通过特定的核函数拟合概率密度分布。常用的核函数有顶帽核，
三角形核，双值核，正态核等。然而当数据维度较高时，核函数法对单元格中数
据的统计要求有大量的已标记观测样本。同样的情况也存在于直方图法中。
 
最易实现的方法为 
k 
近邻法（
K-nearest  neighbor
）。作为一种特殊的密度估计
核函数方法，
k 
近邻认为以数据 
x 
为球心，以 
x 
到第 
k 
个近邻的距离（常用距离的
计算方法见节 
2.1.2
）为半径的球内，密度是相等的。对以 
x 
为中心的球体区域的重庆大学博士学位论文 
18 
密度进行评估：
 
ˆ( )
k
p x
n V
 
                         
（
2.1
） 
其中 
n 
为总样本数，
V 
为以 
x 
为中心，
|x-x
k
|
为半径的球体的体积。太大的 
k 
导致
拟合的概率密度分布更加平滑；而太小的 
k
，则拟合的概率密度分布可能出现尖峰。
因此如何选择 
k 
值是 
k 
近邻法需要考虑的一个重要问题。同时 
k 
近邻法的另一个
缺陷是算法需要存储所有的样本并计算 
k 
近邻，其所需的时间较长。通常这类问
题的解决方法是基于剪辑或压缩的方法减少每个类的原型数目，进而提高计算效
率
[76]
。此外考虑到数据的概率密度函数可能出现严重倾斜或尾部拖得很长的情况，
Breiman 
将 
k 
近邻与固定核函数相结合得到可变核函数用于解决这个问题
[77]
。
 
  
在基于参数的分布假设中，无论使用简单分布（如高斯，泊松，多项式）还是
复杂分布（如混合高斯，
HMM 
等），其算法复杂度都为 
O(N)
；而基于非参数化的
方法拟合概率密度分布的算法复杂度为 
O(N
2
)
。对于未标记的海量数据，基于参数
的分布假设可以直接用于评估参数，而基于非参数化方法的评估方法则需要已标
记的正常数据来精确拟合概率密度函数。
 
  
基于统计的时间序列的异常检测中，如果对数据分布的假设符合真实的数据结
构，且分布（参数）的估计不受异常点的影响，则能够取得很好的效果；利用假
设检验的方法对异常数据进行检测，得到的检测结果中包含对结果的可信度信息，
便于后续决策。然而现实应用中，很难对（高维）数据的分布做出正确的假设；
已有的假设检验方法很难对高维新数据做出有效判断。
 
2.1.2  
基于距离的时间序列的异常检测
 
基于距离的异常检测中，异常点的选择基于异常数据距离其 
k 
近邻的远近。本
方法要求首先对数据之间的距离进行衡量：
 
常用的距离衡量方法有欧式距离（
Euclidean distace
）、余弦、
Jaccard 
相似性度
量（适用于二进制数据和类别数据）和马氏距离（
Mahalanobis distance
，适用于数
据特征具有相关性的情形）。上述的距离衡量方法均可用于时间序列中，除此之外，
对于长度不同的时间序列来说，他们之间的距离可以用动态时间弯曲（
Dynamic 
time wrap
，
DTW
）距离来衡量。在保持序列有序性的前提下，
DTW 
通过寻找序列
的最优弯曲路径，使弯曲的总代价最小
[78]
。
 
经典近邻检测算法检验数据与其第 
k 
个邻居之间的距离，若距离超过了阈值，
则该数据为异常数据。后续的改进有：
 
①
  
改进异常数据的判断标准。经典算法并未关注数据其他邻居的状况，
Zhang
等利用数据的所有 
k 
个邻居的距离进行判断
[79]
，而 
Knorr 
等考虑使用与数据相距 
d
的邻居数进行判定
[80]
。
 2  
基于机器学习的时间序列异常检测算法
 
19 
②
  
提升算法的性能。经典算法的复杂度为 
O(N
2
)
，通过对已有数据进行剪枝，
将确定为正常的数据去除，可以将近邻搜寻的算法复杂度降到线性
[81]
。
 
上述改进算法中，
Knorr 
使用的方法考虑到数据的全局密度，即正常数据所在
区域密度大，而异常数据所在区域的密度小。基于此，可衍生出基于相对密度的
异常检测算法。
 
该算法中常用的特征为局部异常因子（
Local outlier factor
，
Lo F
）
[82]
，用于衡
量数据的局部密度和 
k 
近邻的平均局部密度的比值。若 
Lo F<1
，则该数据为异常
数据，否则该数据为正常数据。文献
[83]
提出了大数据情境下应用基于相对密度的
方法实现对数据的异常检测。具体步骤为应用基于网格的分割技术对数据进行预
处理；对每个网格中的数据子集，基于分布式 
Lo F 
的方法并行的检测密度类型的
异常。在大数据的规模下，基于分布式 
Lo F 
的相对密度异常检测方法只需要少量
的网络间通信，具有较高时间效率。
 
基于距离或者密度的异常检测方法只考虑了数据之间的相关性，因此可以直
接对海量未标记数据进行处理，作为无监督学习算法的一种。但是当数据结构复
杂时很难衡量数据之间的相似性，且如果正常数据没有足够多的邻居，或者异常
数据的邻居太多，则很容易会出现高认错率和误检率。
 
2.1.3  
基于聚类的时间序列的异常检测
 
聚类（
Clustering
）用于将数据进行分割为互不重合的类。每个类内部的数据具
有相同或者相似的性质。聚类的目的并非用于对异常进行检测。然而正常数据聚
成的类的特征与异常数据有较大的差距，故聚类算法可以用于异常检测。
 
因此聚类要求对数据间的相似性（距离）进行度量，常用的距离度量方式可见
节 
2.1.2
。此外对数据的统计特征（图像中的灰度直方图），结构特征（推荐系统中
的用户之间的共同评分数）等特征定义其相似性，也可以实现数据的聚类。
 
基于聚类的异常检测通常假设正常数据和异常数据的特征如下：
  
①
  
正常数据可以被分到一个类中，而异常数据与正常数据的模式不相同，故
而不属于任何一个类。
 
部分聚类算法不要求对所有的数据进行聚类，即存在单个数据未被划分为任
何一类的情况。例如基于密度的聚类（
Density-based spatial clustering of applications 
with noise
，
DBSCAN
）算法；基于层次的鲁棒性聚类（
Robust clustering using links
，
ROCK
）算法；和共享最近邻（
Shared nearest neighbor
，
SNN
）算法等。经过聚类
算法之后，将未被聚类的点看作为异常数据。
 
其中 
DBSCAN 
算法基于密度对数据进行划分。密度较高的区域被连成一个簇。
因此该方法可以发现任意形状的类。简单来说，
DBSCAN 
的过程就是从一个没有
类别的核心对象出发，对数据集进行搜索，把所有密度可达的对象聚成一个簇。重庆大学博士学位论文 
20 
重复这个过程直到所有核心对象都有类别为止。由此过程可以发现不同参数会对
最后聚类的效果产生较大的影响，且样本规模较大时，聚类的收敛速度很慢。
 
基于层次的 
ROCK 
算法通过定义样本点与样本点之间的共有近邻数目（链接）
计算相似度。由于在相似度计算的时候考虑到数据的结构特征，故算法具有鲁棒
性。在层次聚类过程中，每次都对相似度最高的两个类进行合并，最终使不同簇
的共同链接数最少，相同簇的共同链接数最多
[84]
。
ROCK 
算法适用于类别数据，
且更易于分析聚类结果的实际意义。
 
在 
DBSCAN 
算法和 
ROCK 
算法的基础上，提出共享最近邻聚类算法。该算法
适用于不同密度和形状的数据集
[85]
。
 
②
  
正常数据与其最近的类中心距离很近，而异常中心距离其最近的类中心的
距离很远。
 
这种情况下需要先对数据集进行聚类，再通过计算数据与其最近的类的距离
判断其是否为异常数据。典型的，如果数据点与其最近的类超过阈值，则判断其
为异常，反之则为正常。大部分聚类算法均可用于此种情形，例如基于划分的
k-means 
算法，
k-
中心算法等。
 
作为聚类中的经典算法之一，
k-means 
算法具有可伸缩性，适于处理大数据集。
K-means 
通过不断迭代实现最小化数据与其所在簇中心的距离的平方误差和，寻找
紧凑、独立的球状簇。然而，该算法在形成簇的时候要事先确定簇的数目，且对
初值敏感。不同的初值可能对应不同的聚类结果。
 
由于 
k-means 
算法对离群点具有敏感性，一个极值可能会极大的影响平方误差
和的寻优过程。为了降低敏感性，
k-
中心算法用簇中选出的一个实际对象代替簇的
均值来代表该簇。重复迭代实现最小化每个对象与其所在簇中心的距离的绝对误
差和。该算法可以处理任意类型的数据，且对离群点不敏感。
 
③
  
正常数据所在的类包含元素多，密度高，而异常数据所在类包含元素少，
相对稀疏。
 
对经过聚类算法得到的类进行分析，如果类的大小或密度低于某个阈值，则
该类被判定为异常类。这类假设中，如果存在点不能被划分为任意一个已有的类，
则以该点为中心，构建一个新类。同时，在对数据进行类分派的时候，可能存在
一个数据同时属于多个类的情况。这种情况下，通常采取的做法是按照类出现的
顺序，对数据进行分配。出现这种情况的原因是聚类算法使用未标记数据集，数
据本身携带的信息可能不足以使算法对其进行划分。基于聚类的异常检测中，算
法的性能直接影响了异常检测的结果。
 
基于聚类的异常检测算法已经应用在各个领域中，通过与其他方法（如构建
数据特征的模糊集理论）相结合，可以产生更精确的异常检测结果。在工业设备2  
基于机器学习的时间序列异常检测算法
 
21 
的维护中，检测设备状态的系统会产生大量的未标记的时间序列数据。文献
[86]
通
过约束的 
k-means 
算法对数据进行聚类，将元素多密度高的组看做正常类，将元素
少密度低的组看做异常类。通过对类的分析，发现相应数据的行为特征。利用模
糊控制器对正常数据和异常数据进行划分，判断数据分别属于正常和异常的程度。
最后基于数据的 
Lo F 
和模糊程度计算该数据属于异常的分值。这种聚类与其他算
法相结合的方式可以提供更可靠更安全的检测结果。
 
在对 
CCNs
（
Content centric networks
）的攻击检测中，（如 
Do S 
攻击，基于隐
私的攻击（
Preivacy attacks
）等），文献
[87]
采用基于模糊集理论的粒子群优化（
Partical 
swarm optimization
，
PSO
）和 
k-means 
联合的异常检测系统实现有效性检测。针对
k-means 
算法在迭代时易陷入局部最优化的问题，基于粒子群优化算法协助确认类
的个数和类中心；对于确认中心的类，基于模糊决策的方式，对数据计算其与各
类的距离，如果与所有正常类的距离较远，则被判断为异常。
 
基于聚类的异常检测算法采用无监督的学习方式，可以处理海量未标记数据。
其算法的复杂度主要依赖于使用的具体算法，例如 
k-means 
算法为 
O(Nkt)
，
k-
中心
算法为 
O(k(n-k)
2
)
，基于层次的 
ROCK 
算法最坏情况下为 
O(N
2
log N)
，
DBSCAN 
最
坏情况下为 
O(N
2
)
，
SNN 
算法为 
O(N
2
)
等。基于聚类的异常检测算法的性能完全依
赖于使用的聚类算法能否保持正常数据结构的特征。部分聚类算法要求所有的数
据都被划分到相应类中，因此会存在异常数据被错认为是正常的情况。只有当异
常本身无法构成显著的类时，才具有较好的异常检测效果。
 
2.1.4  
基于分类的时间序列的异常检测
 
分类（
Classification
）是指通过对已标记数据集训练分类器，再利用其对测试
数据进行分类。对数据的异常检测就是分类的一种典型应用。常用的分类器有线
性判别函数，决策树（
Decision tree
），支持向量机（
Support vector machine
，
SVM
），
ANNs 
等。对每种分类器，采用一种训练算法对特征空间进行搜索找到最能表示训
练数据集中训练样本及其所属类别关系的模型。最终训练出的分类器的形式将由
训练数据集和错分代价等因素共同决定。
 
基于分类器的异常检测时，如果测试数据没有落入类的判别边界（单类分类），
或者无法归类到任意正常类中（多类分类），则该数据被判定为异常。接下来介绍
常用的几种分类技术。
 
①
  
规则
 
分类器从正常数据构成的训练集中学习并生成规则，如果测试数据无法由生成
的规则导出，则该数据为异常数据。基于规则生成的方法可以同时用于多类分类
和单类分类中。常用的用于规则学习的训练算法有决策树，
Ripper 
等。
 
基于决策树的异常检测使用数据的各类属性作为特征，构建决策树，在不同层重庆大学博士学位论文 
22 
级上对样本进行分类。决策树通常一次构建，多次使用。对于测试样本，对其判
断的次数不超过决策树的深度。对一组给定的数据构建决策树的过程就是设计分
类器的过程。其构造过程为：为决策树的每个节点选择特征。首先对特征进行分
裂，再依据训练集的当前全局信息对数据的各维特征在决策中能提供的信息量选
择合适该节点的特征，例如 
ID3 
使用的信息增益度量
[88]
，
C4.5 
使用的增益率度量
[89]
，
CART 
使用的 
Gini 
指标等
[90]
。对特征分裂后的各样本子集进行特征分裂，选
择提供信息量最多的特征作为节点。重复上述过程直到没有剩余样本或没有剩余
特征或者所有样本属于同一个类为止。决策树可以处理含有多种类型的数据集，
且可以很好的扩展到大型数据库中。通过决策树不难推出便于理解的 
If…Then 
逻
辑表达。然而，决策树容易出现过度拟合的问题，且忽略了数据中各属性的相关
性。
 
虽然决策树的可解释性强，然而其属性分裂度量过程较耗时。为解决基于规则
的分类在大型含噪数据集中的计算问题，
Cohen 
提出了为降低错误而反复增量式修
剪的 
Ripper 
方法。
Ripper 
算法在每一类中建立并生长一个规则。若该规则不与停
止条件相违背，则将其加入规则集中。
Ripper 
算法采用深度优先搜索的策略从每
类提取规则，且提取的规则要尽可能涵盖更多的类。它利用决策树中对信息量的
度量原则不断的添加规则前件，且在规则建立后进行剪枝，以减少过拟合
[91]
。
 
利用上述方法生成规则之后，在测试阶段，可以为每个数据找到最合适的规则
进行匹配。当前规则对于样本数据覆盖的准确率可被用于判断该数据是否为异常。
当前对基于规则分类器的研究主要集中在结合类中样本的概率分布选取并推导规
则
[92, 93]
。
 
另外一种基于关联规则挖掘的异常检测技术，主要用于单类分类中。通过对训
练数据学习发现其频繁出现的序列模式。通常利用 
Apriori 
算法挖掘频繁项，发现
强关联规则
[94]
。在异常检测中，通常采用关联规则进行异常检测，也可以根据测
试数据中频繁项出现的次数判断该数据是否为异常数据
[95]
。
 
②
  
支持向量机
 
SVM 
建立在统计学习理论（ 
Statistical  learning  theory 
， 
STL 
）中的 
VC
（
Vapnik-Chervonenkis
）维和结构风险最小化原则的基础上，利用有限的训练样本
信息，权衡分类器的复杂性和学习能力，获得泛化能力最好的分类器
[96]
。
 
基本的 
SVM 
用于线性可分的数据问题，通过解决约束优化问题找到一个超平
面（
Hyperplane
），使其与最近的两个类的样本距离和最大。距离越大表示该分类
器的泛化（
Generalization
）能力越强
[97]
。由于理想的将数据完全线性分类的边界
在现实中根本不存在，则 
SVM 
需要处理非线性数据的分类。对于近似线性可分的
问题，
SVM 
主要通过对约束的“松弛”来解决，即引入松弛变量对“离群点”进2  
基于机器学习的时间序列异常检测算法
 
23 
行惩罚，惩罚越少，表示分类器越能容忍这类离群点，可以获得更宽松的分类间
隔
[98]
。如果训练数据线性不可分，则需要引入核函数，将当前数据进行非线性变
换投影到可以使用线性分类器的高维空间。当前对于核函数的选择还没有系统的
指导性意见，只能通过实验结果观察了解。常用的核函数有
[72]
：
 
 
表 
2.1  
常用的向高维空间投影的核函数
 
Table 2.1 Commonly used kernel functions for high-dimenson projection 
函数类型
  
数学形式
 
线性函数
  
1 , 1
T p
(

X Y 
)
p 
 
 
多项式
  
, 0
T p
(
r 

X Y 
)
  
 
高斯径向基函数（
RBF
）
 
2
2
exp(

X 

Y 

) 
 
反曲函数（
Sigmoid
）
  
tanh( )
T
k X Y 
 
 
 
基于 
SVM 
的异常检测可以用于单类分类，通过训练得到一个包含所有样本数
据的超球面（若样本线性不可分，通常采用 
RBF 
核函数做非线性变换），测试数据
若是落在超球面之外，则被判定为异常。如果训练集包含了已标记的正常数据和
异常数据，则测试数据可由 
SVM 
可以作为多类分类器判断其所属类别。
 
当前 
SVM 
算法主要与其他算法结合应用于各类领域的异常检测中，如工业控
制冷控制统
[99]
中，
SVM 
结合卡尔曼滤波器和遗传算法等实现异常检测。
SVM 
算
法可以解决高维，非线性，小样本下的机器学习问题，具有较强的泛化能力，然
而其不能处理数据缺失的情况，且对非线性问题没有通用的解决方案，只能根据
实际经验选择核函数来处理。
 
③
  
人工神经网络
 
受生物大脑处理信息方式的启发，
ANNs 
由一系列相互连接的节点构成。每个
单元都有输入（或者是原始数据，或者是经过处理的数据），经过处理（通常使用
线性或者非线性函数进行变换）后会产生输出。因此 
ANNs 
适用于处理含有噪声
的，非线性的数据集。然而原始的数据经过一系列这样的节点处理后，产生的结
果具有不可解释性。故利用 
ANNs 
进行分类或者异常检测时，其使用的特征和分
类规则都是未知的。
 
对于不要求结果具有可解释性的应用中，异常检测过程是利用已有的训练样
本，训练出一个 
ANNs
；对于测试数据，只需将其作为 
ANNs 
的输入，即可得到判重庆大学博士学位论文 
24 
断该数据是否为异常的输出。
 
ANNs 
已经被广泛应用于模式识别，系统管理和控制，非线性系统建模和预测，
信号处理等领域。通常 
ANNs 
有三层：输入层（
Input layer
），隐藏层（
Hidden layer
）
和输出层（
Output layer
）
[100]
。可以使用线性或非线性的函数对数据进行转化和传
递。常用的非线性函数有 
S 
形对数函数，
S 
形正切函数，
logistic 
函数等。由于层
数比较少，这类 
ANNs 
属于浅层学习（
Shallow learning
）。在这类 
ANNs 
中常用的
模型有：误差后向传播 
BP 
神经网络和 
RBF 
神经网络。
 
BP 
在模型训练阶段，通过反向传播网络输出值和目标值之间的误差，根据误
差不断调整相应层参数，以最小化最终的误差。通常利用梯度下降等训练算法搜
索假设空间，选择权值等参数。此过程不断重复直到误差在给定的阈值内。由于
BP 
神经网络性能较好，且比较简单，因此得到广泛应用
[101]
。
 
BP 
中由于每个参数的调整都会对最终的输出产生影响，因此训练的过程较缓
慢，属于全局逼近网络算法。另外一种局部逼近的网络 
RBF 
训练速度较快
[102]
。然
而 
BP 
神经网络以其性能稳定被广泛应用。文献
[103]
利用 
BP 
神经网络，结合所提出
的的交通堵塞特征（路面占有率），实时检测校园交通的堵塞情况。基于泛化的 
II
类模糊规则，对 
BP 
神经网络的输入层和隐含层节点加权，实现对时间序列更精确
的预测
[104]
和异常检测。
 
总体来说，尽管 
ANNs 
善于处理非线性，噪声高的数据，且产生精确的计算结
果，然而其为了寻找最优参数和构建最佳网络结构，需要大量的训练样本，和很
长的训练时间。
 
基于分类的预测方法的实现需要已标记的数据用于分类器的训练，故不可直接
对海量未标记数据进行学习。其算法的复杂度依赖于所采用的具体分类算法：基
于规则的决策树算法最坏情况为 
O(nk)
；
SVM 
算法的最坏情况为 
O(N
2
)
。由于数据
的难以标记的特性，导致实际应用中很难出现对大量已标记数据训练的情况。
 
 
2.2  
基于动态结构的时间序列异常检测
 
上述基于静态结构的异常检测算法应用于在线时间序列时，需要对训练样本进
行更新，以调整参数适应数据的动态变化。通常基于滑动窗口的方式对训练样本
进行更新，每次更新时窗口向前滑动固定的时间长度或者固定的数据个数，获得
与前一时刻等大小的训练样本。由于不同时刻的训练样本只能反映一部分的样本
空间，当前的研究大多利用增量学习和集成学习，基于新的样本空间对旧的规则
进行调整得到新的规则。新的规则既保留了旧规则的特性，也更适应于新的样本。
下面对增量学习和集成学习做简要的介绍。
 2  
基于机器学习的时间序列异常检测算法
 
25 
2.2.1  
增量学习
 
增量学习（
Incremental  learning
）与人类的学习模式非常相似，即人类在逐步
学习新知识的时候不会立即遗忘已经学习的知识。增量学习中，系统在对新数据
进行学习的同时还保持着已经学到的知识
[105]
。因此增量学习天生适用于时间序列
的实时处理。对于基于静态结构的异常检测算法来说，其本身能够对新数据进行
学习，因此只需要训练时不断更新样本数据，调整相应的参数以适应动态变化的
数据。
 
与传统的学习方式相比，增量学习适用于流数据存储模式；同时基于旧规则的
修改比基于新样本重新生成规则节省时间。增量学习的精度会随着所学样本的增
多而提高。常用的方法为增量式 
SVM
，增量式 
SVD
（
PCA
）等。增量学习中要解
决的关键问题是选择多少旧的知识，以及如何将这些知识用于后续新样本的训练
中。
 
经典的增量式 
SVM 
在学习时将当前样本中的支持向量和新的样本集一起用于
分类器的后续训练。由于每一次训练时都丢弃了先前数据集中的非支持向量，故
算法减少了时间复杂度，但是要求增量学习过程中有效的支持向量都被保留
[106]
。
文献
[107]
认为边界支持向量在新的训练样本中也可能称为支持向量。文献
[108]
认为当
前学习时的非支持向量在后续学习时也可能会成为支持向量。因此基于支持向量
超平面的同心圆算法提出半分区的策略选择备选支持向量集。将备选支持向量集
用于增量学习中，能有效增减分类的性能。
 
当前使用的增量式 
SVD 
方法其基础理论如下
[109]
：
 
 
 
(s) 0
,
0 0
(s)0
, (I UU ) C/ K
00
(s) V , ,
T
T
T
T
T
diag L V
U J
K I
diag U CV
U
KI
Udiag C M C
   
   
   
   
 
 
   
  
  
 
   
（
2.2
）
 
对于新增的行或者列向量，采用（
2.2
）对特征向量集合进行进行更新。以推
荐系统为例：增量 
SVD 
中，新的项目评分向量在项目
-
主题矩阵上进行投影，得到
项目在每个主题（类）中的权值；基于用户对各个主题的感兴趣程度（用户
-
主题
矩阵），可以实现用户对项目的评分预测
[110]
和异常检测。文献
[111]
将用户项目矩阵
基于概率进行列采样得到子矩阵，每个子矩阵中预测目标用户对新项目的评分时
采用增量式 
SVD 
方法。
 
与增量式 
SVD 
方法相似，
Li 
等
[112]
提出了增量式 
PCA 
方法用于在线流量检测。
通过新流量对特征向量和权值进行更新。主要步骤如下：用当前特征向量对新的重庆大学博士学位论文 
26 
流量序列进行表示，添加残差作为新的特征向量；基于公式（
2.2
）更新相应的相
应的权值矩阵；利用 
PCA 
对权值矩阵降维，保留权值矩阵的主要成分作为新的权
值矩阵；基于新的权值矩阵对特征向量进行更新。该方法减小了矩阵运算的规模，
降低了时间消耗，具有较好的异常检测性能。
 
2.2.2  
集成学习
 
集成学习（
Ensemble  learning
）是通过对多个分类器（基分类器）输出的融合
得到对新数据的类别判断结果。常用的基分类器构造方法是 
bagging 
和 
boosting
。
常用的输出组合方式为多数投票法。
 
①
  Bagging 
方法
 
Bagging 
方法通过 
bootstrap 
的方法对原始训练集进行有放回的重采样得到多个
和训练集大小一致的副本，并在每个副本上训练分类器。将各分类器对新数据的
判定结果进行组合可得最终的判定结果
[72]
。由于时间序列的数据量是潜在无限大
的，因此采取 
bootstrap 
的采样方法，每个数据被多次选中构成副本的概率非常小。
对海量的历史时间序列的 
bagging 
方法的执行步骤为：将其分为大小相等的若干段
序列；对每段序列分别训练分类器；基于集合策略得到最终的离线分类模型。在
线分类时，通过不断更新训练样本，利用实时数据对分类模型进行调整即可
[113]
。
 
Bagging 
方法适用于分类器变化很大（训练集中的微小改变都会使结果产生巨
大变化）的算法，例如 
ANNs 
和决策树模型。对于微小改变鲁棒的分类算法，
bagging
的改善程度十分有限，例如最近邻分类器。
 
②
  Boosting 
方法
 
Boosting 
方法通过组合弱分类器提高性能。
Boosting 
方法中最常用的是 
adaboost
算法。
Adaboost 
算法初始时为每个训练样本赋予权重，然后利用训练样本对弱分
类器进行训练，并基于权重计算分类器错分样本的误差。基于误差对相应的参数
进行更新。这一过程不断迭代以得到最优分类器。
Adaboost 
在迭代中更在意对于
错分样本信息的学习，以不断提高最终分类器的性能
[114]
。
 
在对时间序列的实时分类中，与 
bagging 
方法类似，
adaboost 
首先基于历史数
据离线地训练一组由弱分类器构成的强分类器。在线应用时，利用新样本对每个
弱分类器分别进行训练，并更新相应的权值，最终完成强分类器的调整
[114,  115]
。
Adaboost 
使用的分类器都比较简单，而且不用做特征筛选，因此得到了广泛的应
用。
 
Boosting 
方法的性能取决于很多因素，包括训练集的大小，分类器的选择，分
类器权值的结合方式以及数据的分布等。
 
集成学习已经被广泛应用于各领域中，如基于自适应人工免疫网络（
Adaptive 
artificial  immune  networks
）集成的乳腺癌的诊断
[116]
；对新车的道路检验数据时间2  
基于机器学习的时间序列异常检测算法
 
27 
序列中，基于两类分类器和单类分类器集成的方法对未见过的异常和已知的错误
进行检测
[117]
，具有对驾驶情境的鲁棒能力；在网络入侵检测系统中基于粒子群优
化为 
SVM 
分类器和 
k 
近邻分类器的集成提供合适的权值，提高了检测的性能
[118]
。
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 重庆大学博士学位论文 
28 
 
 
 3  
基于正常行为模式的时间序列异常检测
 
29 
 
3  
基于正常行为模式的时间序列异常检测
 
 
3.1  
引言
 
作为时间序列的一个典型应用，网络流量序列的数据由系统不断实时的生成。
随着科学技术的发展和网络设备的普及以及多样化、大量的网络应用的出现，导
致产生大量“变异的
”
和新型的异常。已有的基于异常特征的异常检测算法无法精
确的对其进行检测。
 
外界因素的干扰（如夏令时等）或者系统本身的调整（路由表的修改等）导致
采集到的流量数据之间的相关性是动态变化的。基于静态结构的算法无法适应这
种数据动态变化的特性，相应流量时间序列的异常更难以被这类算法检测到。
 
由于网络流量异常的产生原因非常复杂，且存在从未出现过的异常类型。因此，
很难对网络流量进行标记。海量的流量时间序列规模则加剧了标记的难度。
 
同时，时间序列的规模也促使检测到的异常点的规模增大。对大量的异常数据
逐个分析无疑加大了网络管理员的工作量，耗费大量的时间和资源，非常不便于
对异常的实时处理。
 
针对上述问题，本章提出了异常检测的 
Basis Evolution 
模型。从用户（或网络）
的正常行为模式出发，分析流量时间序列的周期性特征；基于周期性特征构建基
函数表示正常网络流量；更新基函数以适应动态变化的新流量；并基于残差进行
异常检测。和其他算法相比，
Basis Evolution 
模型不仅具有良好的检测性能，还以
类的形式向网络管理员（或系统）提供异常结果，节省了时间和资源。
 
 
3.2  
在时间序列中使用 
SVD 
模型
 
本节主要介绍在时间序列中使用 
SVD 
模型。假设每隔

t
时间对输出进行一次
抽样，而抽样时间为
[1,T]
，则变量 
t
x
表示系统在时间区间

t,t 

1

之间的输出，向
量 
 
1
x= ,...,
T
x x 表示[0,T] 
区间内产生的时间序列。
SVD 
无法直接对向量进行处理，
故而需要将时间序列转化为矩阵。最直接的转化方式是等间隔划分时间序列，并
将每一间隔内的时间序列作为列向量按照时间先后顺序放置在矩阵 
M 
中，如公式
（
3.1
）所示：
 
1 1 1
2
t T t
t t T
x x x
M
x x x
  
 
 

 
 
 
       （3.1
） 重庆大学博士学位论文 
30 
其中设置的时间间隔大小为 
t
，为便于计算，
T 

kt 
，
其中 
k
∈Ν，表明 
T 
是 
t
的整数倍。则 
M 
是
t 

k 
的矩阵。
 
SVD 
将 
M 
分解得到三个矩阵：
 
T
M 

U 

V 
         （3.2
）
 
其中 
U 
是
t

t 
的酉矩阵，
V 
是
k 

k 
的酉矩阵，则 
U 
可以看作是协方差矩阵
T
MM
的特征向量矩阵，而 
V 
可以看作是协方差矩阵
T
M M 
的特征向量矩阵。
U 
和 
V 
的
向量均称为 
M 
的奇异向量。 
 
ii 
i

1,r



  
（
r 

rank(M) 
）
是
t

k 
对角矩阵，其中 
M
的奇异值
ii
 
按照值的大小依次排列。
 
设对角矩阵 
 
的前
n
个奇异值保持的能量通过前 
n
个奇异值的能量和占总能量
的比例来表示：
  
2 2
1
r
i ii ii
i
e 
 

 
 
;
1
n
n i
i
E e

 
 
      （3.3
） 
其中 
e
i
为每个奇异值保持的能量。现实情况下的对角矩阵 
 
中，很小的 
n 
就可
以保持很高的能量。故而可以取 
U 
和 
V 
的前 
n 
个奇异向量对 
M 
进行近似：
 
T
n n n
M 

U 

V 
        （3.4
）
 
n
P 

MV 
表示对 
M 
进行线性变换，将 
M 
投影到 
n 
维向量空间中。
P 
中的每一
列向量看作是 
M 
的主成份。对主成分的分析可以得到 
M 
的主要信息。将其应用于
图像领域，即矩阵 
M 
表示图像，基于公式（
3.4
），用 
U 
或者 
V 
的前 
n 
个奇异向量
表示 
M
，成功实现矩阵的低维表示。这种表示不仅除去了冗余的特征和噪声，还
减少了图像的存储空间，实现了对图像的压缩
[119]
。
 
此外 
SVD 
对于矩阵的分解过程在不同的领域具有不同物理意义。例如在文本
分类中，矩阵 
M 
是单词和文本的关联矩阵，
U
n
表示单词和隐含主题的相关性，而
Vn 
表示文本与隐含主题的相关性，这类解决问题的方法叫做潜在语义索引（
Latent 
semantic  index
，
LSI
），可以用于文本的聚类和分类。类似的，在协同推荐领域也
可以使用 
SVD 
方法进行预测
[120]
。
 
 3  
基于正常行为模式的时间序列异常检测
 
31 
3.3  
基于用户正常行为模式的异常检测
 
3.3.1  
问题的定义和解决方案的分析
 
3.1 
节的四类问题可以被总结为从海量未标记数据中提取并更新有效特征，以
精确检测异常点，并对异常点进行聚类的问题。具体的问题定义和解决方案的分
析如下：
 
①
  
对海量未标记数据进行清理，使其直接用于异常检测。
 
由于异常数据的数目比较少，很难从海量未标记数据中对其进行人工标定。相
反，正常的数据样本则较容易获取。在预处理阶段，对数据的清理就是对数据的
异常和噪声进行清理，使清理过的数据全部为“正常点
”
。
 
由于任何一个漏检的异常点都可能会影响后续的异常检测，因此利用集成学习
的思路，采用多种异常检测算法联合的策略提高检测精度。过高的检测精度意味
着高误检率，本章通过插值的方式修改异常值，减小过高的误检率带来的信息损
失。
 
②
  
选择少量、易理解的基函数表示正常网络流量。
 
通常一个地区的用户（或网络）的正常行为模式是稳定的，这通常是用户上网
习惯以及网络流量的采样方式导致的。用户的上网习惯受到时间，工作，学习，
兴趣等的影响，例如办公区用户在上班时接入网络，下班时下线，这导致了相应
的网络流量在工作日呈现了周期性特征。而网络流量的采样通常是以固定的频率
进行，因此对流量的采集也具有周期性。这种周期性通常为日，周，月，年等时
间尺度的周期性。
 
与 
PCA 
类似，特征的选择问题就是在无限空间中寻找能用作基的函数，这种
无约束的优化问题具有无穷多个解。基于用户（或网络）正常的行为模式，我们
认为选择的基函数应当具有周期性，相应的生成的基函数具有明显的物理意义，
具有可解释性。
  
③
  
更新基函数适应数据的动态变化。
 
由于各类外界或者内部因素的干扰，用户（或网络）的正常行为模式会缓慢的
变化，相应的流量也发生改变。例如由于夏令时的实行，部分国家或地区的上下
班时间出现变化，导致相应地区的网络流量高峰期出现了偏移（从 
9
：
00am 
左右
变为 
8
：
00am 
左右）；或者用户不再使用某个网络服务提供商（
Internet  service 
provider
，
ISP
）提供的网络接入服务，导致网络路由器等设备的信息发生相应的改
变，导致流量发生变化。从统计学角度来说，这类行为模式变化的比较缓慢。
 
基于此，利用增量学习的思路，对基函数进行更新，使其在保持已有特征的基
础上，逐渐适应网络的变化。如果新基函数在重构新样本时产生巨大的误差（如
超过某个阈值），则表明用户（或网络）的行为模式发生很大的变化。如果这种变重庆大学博士学位论文 
32 
化是正常的，则需要清理数据，重新生成基函数。
 
④
  
对异常点聚类，并评价聚类的性能。
 
由同一原因产生的流量异常点发生的时间比较集中。因此基于时间上的相似
性，对异常点进行自下而上的层次聚类。将相同原因产生的异常点聚为一类，便
于为网络管理员分析数据时提供更好的支持，使管理员能够及时的发现异常流量
产生的原因。同时对异常类进行分析，大大降低了管理员对异常点分析的工作量，
减少了处理异常的资源和时间消耗。
 
我们根据与标准类的接近程度对检测的异常类进行性能评估。分别从异常数目
和异常持续时间角度定义了两种评价标准。每个评价标准包含两个指标，分别衡
量了类之间的一致性和聚合性。
 
3.3.2  
流量时间序列的异常检测架构（
Basis Evolution
，
BE
）
 
表 
1.1 
中各方法生成的基函数或者从时域或者从频域或者从空间域的角度描述
了网络流量的特征。这类方法假设我们对于网络流量本身的特征了解很少，因此
需要从各个域中发现其特征。然而由 
3.3.1 
节知，网络流量具有很强的周期性，即
在频谱图中，标准的网络流量在 
24 
小时和 
1 
周对应得频率处能量最大
[121]
。因此
在基函数生成中可添加周期性约束。一种解决方法是对不同周期下的流量成分进
行 
SVD 
操作，得到相应周期下保持大部分能量的特征向量集合（又称为基函数族）。
聚集所有周期下的基函数族即可得到用于表示正常流量空间的一组基。
 
表 
1.1 
中的方法通常采用两种形式表示新数据：使用一个固定的基或者重新生
成基。前者可能会增大重构新数据的误差，后者会耗费计算资源。值得一提的是，
通过增量的方式对已有的基函数进行更新以表示新数据的方法可以有效的减少计
算所耗费的时间
[112]
。因此本章通过对已有的基不断的进行演化，使其能动态适应
新数据。
 
图 
3.1 
为本章提出的流量时间序列的异常检测架构 
Basis Evolution
，主要包含 
4
个部分：数据清理（
Data cleaning
），基生成（
Basis generation
），基更新（
Basis update
）
和异常检测（
Anomaly detection
）。其中异常检测主要包括异常点检测（
Anomalous 
point detection
）和异常点聚类（
Anomaly clustering
）。
 
为了能够更加正式的描述 
Basis Evolution 
架构，我们在 
3.2 
节的基础上重新对
网络流量数据进行数学描述。假设在时间 
t
j
开始每隔 

t 
时间采集流量。变量
j
t
x 
表
示在时间段 

1
,
j j
t t



的总流量测量值。每
b 
个流量测量值为一个流量块，进而我们
有
0
{ , , }
n
X 

x x 
，对于任何
m
x 

X 
，
 
1
, ,
j j b
T
m t t
x x x
 

 
 
      （3.5
）
 3  
基于正常行为模式的时间序列异常检测
 
33 
其中 
j 

bm
，
X 
跨越的时间区间为 

T 

b

t 
。在 
Basis Evolution 
架构中，使用 
X 
作
为数据输入，通常 

T 
为周期的倍数，例如两周等。
 
对于第一个数据段
0
x 
，由于无法获得已标记的数据，对于包含异常较多的流量
序列，我们利用多种异常检测算法对其进行检测，并对异常点进行插值填充，使
整个序列保持网络流量的特性。具体的操作可见节 
3.3.3
。
 
对经过清理的第一个数据段提取基函数
0
H 
。基于
0
H 
，可以对该数据段进行重
构，计算重构误差
0
r 
。通过重构误差，可以通过阈值的方式检测异常点。将这一步
产生的基
0
H 
传递到对第二个数据段的处理中，
Basis Evolution 
利用基函数更新程序
将当前基
0
H 
更新为
1
H 
，使其更适应新到来的数据段。对于后续的每个数据段都重
复该过程可得到最新的基。
 
 
 
图 
3.1  
某一链路上的 
Basis Evolution  
架构图。在时间标记为
0
T 
时，对数据段
0
x 
进行清理，得
到“无异常”的数据段
'
0
x 
。基于
'
0
x 
生成基的集合
0
H 
。是
'
0
x 
在
0
H 
上的投影。重构误差
0
r 
是
0
x
和
0 0
W H 
的差值。对
0
r 
进行异常检测，得到异常点集合
0
P 
并对其进行聚类得到
0
A 
。在接下来
的任意时间标记（如
m
T 
）处，将旧的基集合
m1
H

演化为新的基集合
m
H 
，计算重构误差，并
对其进行异常检测。该过程一直持续。
 重庆大学博士学位论文 
34 
Fig.3.1 A bird’s eye view of Basis Evolution framework for one single link. At time index 
0
T 
,we 
clean the data segment 
0
x 
, and get the “anomaly free” data segment 
'
0
x 
. Then we derive a basis set 
0
H 
. The projection of 
'
0
x 
  on 
0
H 
  is 
0
W 
. Reconstruction error 
0
r 
  is the difference between 
0
x 
 
and reconstructed series 
0 0
W H 
. Anomaly detection on 
0
r 
, finds anomalous points 
0
P 
  , and these 
are clustered into anomalies 
0
A 
. At subsequent time indices (e.g., 
m
T 
), we evolve the old basis 
m1
H

  into 
m
H 
, and calculate the reconstruction error 
m
r 
  for anomaly detection, and repeat 
anomaly detection. 
 
3.3.3  
数据清理（对无标记数据的联合异常检测）
 
由于现实获得的数据都是未标记且未清理的数据集，因此有必要在数据预处理
阶段将异常点和噪声去除，以减少其对后续操作的影响。目前尚无完美的异常检
测方法，因此借鉴集成学习中多种分类器协同分类的思想，采用多种类型的异常
检测方法进行检测，并对检测结果进行合并。
 
假设第
th
d 
个方法进行异常检测产生的异常点集合是
d
A 
，其中 
d 

{1, , D}
，则
最终检测到的异常点被表示为
1
D
d d
U A

。这样做的目标是保证检测到的异常集合与真
实异常集合的交集最大。这种只追求高精度的联合检测方法导致最终检测的结果
具有很高的误检率。然而若这一步骤中的异常点没有被发现，那么它将直接影响
到后续所有操作。因此在此阶段，我们倾向于将异常点尽可能的全部清除。本章
用于联合的算法是基于 
PCA 
和 
ANNs 
的异常检测算法。
 
通常对于检测到的异常点的处理是删除该点，然而高误检率可能导致这一操作
丢失大量正常点的信息。因此在删除异常点之后，我们对空白进行填充。填充值
通过对基于 
ANNs 
的预测值和适应周期性特征的线性插值进行加权可以得到。通
过对数据的填充可以使信息的丢失造成的影响降到最小。
 
一些异常可能隐藏在大异常之后，因此需要对数据进行连续多次的清理，即整
个联合检测的过程需要多次重复，直到重复次数达到阈值或者再无异常点可被检
测出来（通常最大迭代次数设置为 
5
，因为大部分的检测早在 
5 
次以内就无法发现
异常点了）为止。具体的操作流程如图 
3.2 
所示。
 3  
基于正常行为模式的时间序列异常检测
 
35 
 
图 
3.2  
数据清理算法。采用 
PCA 
和 
BP 
神经网络（
NNBP
）算法发现异常。如果检测到异
常点，将其移除，并用插值和预测的方法对空白处进行填充。重复整个检测过程直到没有发
现更多的异常或者迭代次数超过了阈值。
 
Fig. 3.2 The data cleaning algorithm. We apply PCA and NNBP find anomalies. If anomalies are 
detected, we remove them, and replace gaps using interpolation and prediction, then repeat detection 
until no more anomalies are found or the number of iteration exceeds the threshold. 
 
通过多个算法的联合检测，可达到最高的检测精度。通过插值和预测的方式对
异常删除时产生的空白进行填充，可以将误检率的影响降到最小。这种联合的策
略适用于对未标记数据的预处理。
 
3.3.4  
基函数生成
 
该阶段的目标是找到一个函数集合，可用于拟合“正常流量”空间τ。基函数
生成问题可以表示为寻找一个能最小化重构误差的基函数集合：
 
( )
( ) ( )
1
, ,
arg min
l
L
l l
l
L w h
x w h

 
 
      （3.6
）
 
其中 
x 
是输入数据段， 
L 
是基向量的数目， 
w 
是权重，
(l)
h 
是基向量。
 
  
公式（
3.6
）的解具有开放性，其中的一个解为
(1)
h 

x 
，
(1)
w 

1
，且 
L 

1 
。由
于网络流量呈现周期性，因此我们认为基向量也应当具有周期性。设周期为
i
c 
，其
中
i 

1, ,I 
。将所有周期按照大小增序排列。理论上来说
i
c 
应当包含周期的整数
倍，但是为简化算法，本章只关注于日和周的周期。例如，如果每天采样的样本
数为 
24
，则日和周的周期可以表示为
1
c 

24 
和
2
c 

168 
，我们选择最后一个周期为
整个数据段 
x 
所包含的最大周期数，即
3
24
24
b
c
 

 
 
。
 重庆大学博士学位论文 
36 
  
令
( , )
i
c j
h 
表示周期
i
c 
中第 
j 
个基向量，则对于
( , )
i
c j
h 
中的每个元素，我们有
 
( c, j) ( c, j)
i i
i
k k ac
h h


        （3.7
）
 
其中 
k 
和 
a 
为任意有效的正整数。因此
 
( ) ( ,1) ( , )
| |
i i i i
C c c J
H h h

 
 
      （3.8
）
 
且基集合为
1
( )( )
| |
i
CC
H 

H H 

 
。
 
  
公式（
3.6
）的重构误差问题可以由新的目标函数来定义：
 
( )
( , ) ( , )
1 1
, ,
arg min
i
i i
l
I
J
c j c j
i j
L w h
x w h
 
 
 
     （3.9
）
 
其中基集合的大小为
1
I
i
i
L J

 
 
。
 
  
本章的算法以迭代的方式在各个周期中搜寻最优解以不断的优化对网络流量
（残差）序列的近似。算法从最小的周期开始，并依照周期从小到大的顺序不断
迭代进行。在每个阶段，我们固定在其余周期中的参数值，并只对当前所处的周
期下的参数进行更新。通常周期较大的情况下，相应的参数设置为 
0
。因此在阶段
n
，
 
1
( )( , ) ( , )
1 1
i
i i
n
J
nc j c j
i j
r x w h

 
  

       （3.10
）
 
其中 
n 

1
，当 
n 

1
时，
(1)
r 

x 
。下述公式（
3.11
）可以用于优化基函数及相应的
权值。
 
( , ) ( , )
( )( , ) ( , )
1
, ,
arg min
n
n n
c j c j
n n
n
J
nc j c j
j
J w h
r w h

 
 
      （3.11
）
 
  
公式（
3.11
）的一个有效的解决办法是进行 
SVD 
操作。由于 
SVD 
只能作用于
矩阵，而非向量。因此首先将向量
(n)
r 
转换为矩阵
(n)
R 
。转换的方式为滑动窗口法，
如公式（
3.12
）所示：
 
0 1 1
1 2
1 2 1
( ) ( ) ( )
( ) ( ) ( )
( )
( ) ( ) ( )
c
n
c
n
b c b c b
n n
n n n
t t t
n n n
n
t t t
n n n
t t t
r r r
r r r
R
r r r

    
 
 
 

 
 
 
 
      （3.12
）
 3  
基于正常行为模式的时间序列异常检测
 
37 
其中新矩阵的每一行包含了
n
c 
个值，一共有 
( 1)
n
b 

c 
 
行。通常认为 
( 1)
n n
b 

c 
 
c 
。
每完成一行的填充之后，窗口向前滑动一个单元，取
n
c 
个值用于填充下一行。事
实上滑动窗口构建矩阵的方法是在不破坏数据结构的基础上对样本进行了填充，
增加了可用样本数，以便于后续处理。
 
  
根据公式（
3.2
）和（
3.4
），对矩阵
(n)
R 
进行 
SVD 
操作，可得
 
( )
1
1
;
n
n T
j j j
j
J
T
j j j
j
R u v
R u v








      （3.13
） 
其中 
R 
通过保留
(n)
R 
的前个
n
J 
主成分对其进行拟合。根据能量公式（
3.3
），可以表
示特征向量所占有的能量比例。通常设置能量比例的阈值
 
0.3
，则所取的第
n
J 
个
特征向量所具有的能量必须高于 
0.3
。
 
  
由于
U 
中前
n
J 
个向量保持了矩阵
(n)
R 
很大一部分的能量，因此可直接将其看作
为基函数，即
 
( , )
n
c j
j
h 

u
       （3.14
） 
相应的权值可表示为：
 
( , ) ( )
( , )
( )
n
n
c j n
c j
n
h r
w
r

      （3.15
）
 
  
至此，可得到在周期
n
c 
时，重构误差所需要的基函数族及相应的权值。重复该
过程直到所有的周期结束。这种基函数的生成算法叫做 
SVD_SC 
算法，具体步骤
如表 
3.1 
所示。值得注意的是步骤 
6 
的 
Matlab 
标记是用于表示向量的级联。该算
法主要用于初始数据段
'
0
x 
的基生成过程，以及网络变化较大的时候。
 重庆大学博士学位论文 
38 
表 
3.1  
用于基生成的 
SVD_SC
（
SVD on specific cycles
）算法。
 
Table 3.1 A SVD_SC algorithm for basis generation. 
输入：
 
     
流量数据段 
x 
；
 
     
流量采样间隔时间 

t 
天；
 
     
x 
的大小 
b 
；
 
     
能量比例的阈值γ。
 
输出：
 
     
基集合 
H 
；
 
     
权重集合
W 
；
 
     
重构误差 
r 
。
 
     1.
初始化周期集合：
 
1 7
, ,
b t
c
t t t
  
 
 
 
  
 
；
 
     2.
令
(1)
r 

x 
；
 
     3.for  
n 

1, , I 
  
     4.//
根据公式（
3.12
）从
(n)
r 
中构造矩阵
(n)
R 
。
 
     5.   for 

1, , 1

n
row 

b 

c 
 
 
     6.    
(n)
r 
上设置大小为
n
c 
的窗口向前滑动，每滑动一次，得到
(n)
R 
的一行
 
1 2
( ) ( ) ( ) ( )
; , ,
row row c
n
n n n n
t t
R R r r
  
  

 
；
 
     7.   end for 
     8.   
对
(n)
R 
应用 
SVD 
算法，使
(n) T
R 

U

V 
；
 
     9.   
令 
j 

1 
；
 
     10.   while 
j
e 
 
 
     11.     
j 

j 

1
；
 
     12.   end while 
     13.   
令
n
J 

j 
；
 
     14.   
U 
的前
n
J 
列构成一个基函数族
 
( )
1
{ , , }
n
n
C
J
H 

u u 
；
 
     15.   
根据公式（
3.15
）计算相应的权重值
 
( ) ( ,1) ( , )
, ,
n n n n
T
C c c J
w 

w w 

  
；
 
     16.  
( 1) ( )( ) ( )
n n
n nC C
r r H w

 
；
 
     17.end for 
     18. 
I1
r r

 
. 
 
3.3.5  
基函数更新
 
对于任意一个新的数据段 
x
m
，我们将旧的基集合
(m1)
H

进行演化得到新的适合
该数据段的基集合
( m)
H 
。这种演化符合我们的预期：演化形成的基集合反应了用
户（或网络）的正常行为模式的缓慢变化导致的流量变化。演化的方式生成新的3  
基于正常行为模式的时间序列异常检测
 
39 
基集合能够检查新数据段中的异常。相比于利用新数据重新生成基集合，对基函
数的演化避免了数据的清理过程，节省了大量的计算时间和资源。
 
  
基函数的演化问题可以表示为每次分别对基集合中的一个基向量进行演化，而
其余的基向量保持不变。因此基更新要解决的问题是：
 
 
( ) ( )
( ) ( ) ( ) ( ) ( ) ( )
( 1)
, ,
arg min
( ) |
k k
m m
l l k k k k
m m m m m m m
l k
w h
x w h w h d h




 

   
   （3.16
）
 
其中 
k 

1, ,L
，
( k)
m
h 
是新的基向量；
( )
( 1)
k
m

 
表示旧基向量的集合
( ) ( )
1 ( 1)
{ , , }
k k
m
h h

；
d
用于衡量旧的基函数与新的基函数之间的距离；参数λ用于精确度（拟合当前数
据段的）和相似度（与旧的基向量的）之间的均衡。经过多次实验，我们发现一
个简单的组合：
 
1
且只衡量与前一个时间段的基向量
( )
( 1)
k
m
h

，以及历史的均值基
向量
( 1)
k
m
h

的距离（如公式（
3.17
）），即可达到较好的效果。
 
 
( ) ( ) ( ) ( ) ( )
( 1) ( 1) ( 1)
|
k k k k k k
m m m m m m
d h h h h h
  
    
   （3.17
）
 
其中
( 1)
( )
( 1)
0
1 
m
k k
m i
i
h h
m



 
 
。
 
公式（
3.16
）第一项中的误差
(l) (l)
k m m m
l k
e x w h

  
 
表示只移除第
k 
个基向量时
产生的重构误差。第二项用于惩罚新的基向量相对于历史基向量的变化。此外还
对新向量中的第 
j 
个元素添加约束实现平滑：
 
   
( ) ( ) ( )
min ( ) ( ) max ( )
k k k
i m i
i i
h j 

h j 

h j
     （3.18
）
 
其中
i

[0,m

1]
。将第 
k 
个基向量中每个元素的历史最小值和历史最大值分别集合
起来，得到第 
k 
个基向量的最小值和最大值集合分别为
 

 

( ) ( )
( 1)
[0, 1]
[1, ]
min min ( )
k k
m i
i m
j b
h h j

 

 
    （3.19
） 

 

( ) ( )
( 1)
[0, 1]
[1, ]
max max ( )
k k
m i
i m
j b
h h j

 

 
    （3.20
）
 
进而所有历史基向量的最小值集合和最大值集合可以表示为
 
 
min ( )
( 1) ( 1)
[1, ]
min
k
m m
k L
h
 

 
     （3.21
） 重庆大学博士学位论文 
40 
 
max ( )
( 1) ( 1)
[1, ]
max
k
m m
k L
h
 

 
     （3.22
）
 
通过交替固定变量的迭代式方法，我们可以得到
( k)
m
h 
和
( k)
m
w 
的解
[122,  123]
。为了
便于计算，我们将误差
k
e 
转换为矩阵 
 
的形式，且 
 
的列数与基向量
( k)
m
h 
的长度一
致（例如长度为
c 
）。由于新数据段的采样长度
b 
为
c 
的整数倍，故而矩阵
 
的形式
为：
 
(1) (1)
( 1) (2 )
( 1) ( )
k k
k k
k k
e e
e c e c
e b e b

 
 

 

 
 

 
     
（
3.23
）
 
对于每个新的基向量的权重，我们初始化为
 
(k)
m
w 

w y 
       （3.24
）
 
其中 
y 
是长度
b
c
的满足独立同分布的标准正态分布变量。则
( k)
m
h 
和
( k)
m
w 
的迭代规则
为：
 
( ) ( )( 1) ( 1)
( )
( )
( )
T k k
k km m
m m
T k k k
m m m
w h h
h h
w wh h h
 

 
 

 
    （3.25
） 
( ) ( )
( )
k
m
k k T
m m
h
w w
wh h


     （3.26
）
 
其中 和 分别是元素级乘法和除法。当迭代到一定次数，或者误差降到阈值的时
候，可以得到
 
/
( )
1
1
/
b c
k
m i
i
w w
b c

 
 
      （3.27
）
 
其中
i
w 

w 
。表 
3.2 
表示了基函数的更新算法。
 3  
基于正常行为模式的时间序列异常检测
 
41 
表 
3.2  
基向量更新算法。
 
Table 3.2 Basis update algorithm. 
输入：
 
     
新的流量数据段
m
x 
，以及
m
x 
的大小 
b 
；
 
     
历史基集合
(m

1)
 
；
 
(m

1)
 
的均值集合
(m

1)
 
；
 
    
(m

1)
 
的最小值集合
min
(m

1)
 
和最大值集合
max
(m

1)
 
；
 
     
权值集合
(m1)
W

；
  
     
重构误差的阈值 
 
；最大迭代次数 
 
和 
 
。
 
输出：
 
新的基集合
m
H 
；
 
权重集合
m
W 
；
 
     
重构误差 
r 
。
 
     1. 
m(m1)
H H

 
，
m(m1)
W W

 
; 
     2.
迭代次数
1
n 

0 
，
2
n 

0 
；残差
1 m
e 

x 
；
 
     3.while 
1
n 
 
且
  
r 
 
 
     4.for  
k 

1, , L 
  
     5.   
(l) (l)
k m m m
l k
e x w h

  

；
 
     6.     while 
2
n 
 
  
     7.       
根据公式（
3.23
）计算残差矩阵ε；
 
     8.       
根据规则（
3.25
）更新基向量得到
( k)
m
h 
；
 
     9.       
令 
c 
为
( k)
m
h 
的长度；
 
     10.       for  
j 

1,..., c 
 
     11.          if 
( ) ( )
( 1)
( ) min ( )
k k
m m
h j h j

 
  then 
     12.           
( ) ( )
( 1)
( ) min ( )
k k
m m
h j h j

 
；
 
13.          if 
( ) ( )
( 1)
( ) max ( )
k k
m m
h j h j

 
  then 
     14.           
( ) ( )
( 1)
( ) max ( )
k k
m m
h j h j

 
；
 
     15.          end if
；
 
     16.       end for
；
 
     17.       
根据规则（
3.26
）和（
3.27
）更新
( k)
m
w 
；
 
     18.      
2 2
n 

n 

1
；
 
     19.   end while
；
 
     20.  
(k)
m m m
H 

H h 
且
(k)
m m m
W 

W w 
；
 
     21.end for 
22.
计算拟合误差
 
( ) ( )
1
L
l l
m m m
k
r x w h

  

；
 
1
1
( )
b
i
r r i
b

 

；
 
     23. 
1 1
n 

n 

1 
；
 
     24.end while. 重庆大学博士学位论文 
42 
如果误差 
r 
在经过有限次迭代后不满足阈值（例如前一次的平均误差值），则
表示算法不收敛。这种不收敛表示新数据对应的用户（或网络）行为模式发生了
巨大的变化，对旧的基向量的演化已经无法对新的流量模式进行表示。因此需要
利用数据清理和基函数生成重新生成一个全新的基集合。
  
 
3.3.6  
异常检测和对异常点的聚类
 
许多文献在检测到异常点之后便停止研究。然而许多异常点可能是由同一个原
因产生的。因此这类点之间具有内在的关联特性。当系统只提供单独的异常点时，
网络管理员只能获得很少的信息来分析每个异常点代表的异常事件。这不但会耗
费大量的时间，也增加了分析的难度。而在决策之前将具有关联关系的异常点聚
集在一起，以类别为单位进行研究可以为后续决策提供更多的信息，例如异常持
续的时间等。这样更便于挖掘引起异常流量的原因。同时，以类别为单位对异常
进行分析大大降低了网络管理员需要处理的异常点数目，节省了大量的时间。异
常点聚类后，网络管理员只需关注更有价值的异常类。例如流量发展缓慢，但持
续时间长的异常通常比单点异常更具有研究意义，因为它可能是由网络中的热点
事件触发的。
 
本章利用相同事件产生的异常具有集中性的特征，衡量异常点之间的时间间
隔，并将间隔小的相邻异常点看作一类，认为它们是由相同的原因产生的异常。
因此异常检测的过程包括异常点的检测和对异常点的聚类两个部分：
 
①
  
异常点检测。基于阈值的方式对重构误差进行检测发现异常点。对于任意
重构误差 
r ,  
我们设置其上下限为
[p 

q*

, p 

q*

]
，其中 
p 
和
 
表示
r 
的均值和
标准差。参数 
q 
用于设置不同大小的边界，进而可以计算对异常的检测精度和误检
率。 
r 
中任意的点如果落在限定的边界之外，便被认为是异常的。
 
②
  
异常点聚类。本章采用自底向上的层次聚类算法对异常点进行聚类。具体
算法如表 
3.3 
所示。与表 
3.1 
类似，
Matlab 
的标识被用于步骤 
12,18 
和 
25 
中，表示
对向量的拼接过程。
 
鉴于相同原因引起的异常流量发生的时间比较集中，因此定义任意两个类中
心的时间间隔作为两个类之间的距离。距离较小的异常点更容易被聚在同一个类
中。由于本章提出的聚类算法只用到了点的时间属性，因此其也适用于其他的异
常检测方法中。在后续的实验中，我们对由任何异常检测算法生成的异常点序列
都进行了聚类，并对聚类效果进行了衡量和分析。
 
 
 
 3  
基于正常行为模式的时间序列异常检测
 
43 
表 
3.3 
基于自底向上的层次的异常点聚类算法
 
Table 3.3 A bottom-up hierarchical clustering algorithm for anomalous points 
输入：
 
     
流量异常点的时间序列 
 
1
t , ,
n

t 

t 
；
 
     
距离的阈值
 
；
 
     
最大迭代次数
 
；
 
输出：
 
     
异常点所聚成的类的集合
V 
以及相应的类的中心的集合
U 
；
 
     1. 
(0)
t 

t 
；
 
     2. 
(0)
k 

n 
；
 
     3.  
m 

1
；
 
     4. while  
m 
 
  
     5.    
k 

1 
；
 
     6.    for 
( 1)
1, , 1
m
i k

   
  
     7.       
j 

i 

1 
；
 
     8.       
距离
 
( 1) ( 1) ( 1)
( , )
m m m
i j i j
d t t
  
  
；
 
     9.       if 
( 1)
( , )
m
i j
d 


 
 
     10.       
( 1) ( 1)
( )
2
m m
mi j
k
t t
t
 

 
；
  
     11.       
( ) ( ) ( 1) ( 1)
{ , }
m m m m
i j
V V t t
 
  
；
 
     12.       
( ) ( ) ( )
,
m m m
k
t 


t 

t 

 
；
 
13.        
k 

k 

1 
；
 
     14.        
i 

i 

1 
；
 
     15.      else 
     16.       
( ) ( ) ( 1)
{ }
m m m
i
V V t

 
；
 
     17.      
(m) (m1)
k i
t t

 
；
 
     18.      
( ) ( ) ( )
,
m m m
k
t 


t 

t 

 
；
 
     19.       
k 

k 

1 
；
 
     20.      end if 
     21.   end for 
22.   if 
( 1)
( , )
m
i j
d 


 
 
23.    
( ) ( ) ( 1)
{ }
m m m
j
V V t

 
；
 
24.    
(m) (m1)
k j
t t

 
；
 
     23.    
( ) ( ) ( )
,
m m m
k

tt 

t 
 
 
；
 
     24.     
k 

k 

1 
；
 
     25.   end if 
     26.  
(m)
k 

k 
；
 
     27.   
m 

m 

1 
；
 
     28.end while 
     29. 
(m)
V 

V 
，
(m)
U 

t 
. 重庆大学博士学位论文 
44 
3.4  
基于合成数据的实验及分析
 
由于网络流量产生异常的原因非常复杂，而网络流量序列的数据规模很大，对
于网络流量时间序列进行标记非常难，会耗费大量的人力物力。现实中很难找到
已标记的网络流量时间序列进行分析研究。因此，本章采用合成数据和真实世界
的数据分别进行实验以验证提出方法的效果。其中合成的数据是自行构造的，不
真实的数据，为了精确提供算法的精确度而产生的
[8]
。和其他异常检测的方法如
PCA
，
RPCA
，
IPCA
（
Incremental PCA
），
OMP 
以及 
NNBP 
相比，本方法具有更好
的检测性能，其中误检率能低至 
1.0 × 10
−4
。对于没有标记的真实数据，我们只研
究了本方法与常用方法之间的关系。 
基于合成数据对于验证异常检测算法的性能非常重要，特别是很难找到已标记
的真实数据的情况下
[18]
。鉴于我们的算法目标在于取得更低的误检率，因此需要
测试大量已被标记的数据。此外，我们还考虑测试算法对异常点进行聚类的性能。
已知的数据集中不存在这类信息，故而需要合成数据测试。
 
基于合成数据的实验包含了多种异常检测技术，并试图从实验结果中发现它们
的特征。因此合成的数据不需要与现实数据完全一致，只需要能突显各技术的特
性即可。我们一共实验并比较了六种异常检测技术（包含 
Basis Evolution
），采用三
对标准对它们进行评价。另外五种技术分别是：
 
①
  
基于 
OMP 
的异常检测算法。是 
Basis Detect 
算法的原型，使用 
OMP 
算法
从具有时频特性的离散余弦函数构成的字典中选择重构误差最小的原子（
atom
）
作为基向量对正常流量进行表示。其异常检测程序与 
Basis Evolution 
类似：找到数
据段
0
x 
在各个频率上投影最大的前 
L 
个原子
L
 
。对于新数据段
m
x 
，利用
L
 
对其进
行表示，即对公式（
3.28
）进行求解：
 
arg min
L
m L L
x




 
      （3.28
） 
其中
L


表示
m
x 
在
L
 
上的投影幅度。进而得到重构误差 
OMP
m L L
r x 
 

  
，并按
照 
3.3.6 
节的描述对异常进行检测。
 
②
  基于 PCA 
的异常检测。该方法为初始数据寻找 
k 
个具有最大特征值的特
征向量，并用其重构数据段
m
x 
，重构误差为
PCA
m m
r 

x 

x 
，其中
m
x 
是重构的数据，
而
PCA
r 
如同 
1
）所示用于异常检测。 
③
  
基于 
RPCA 
的异常检测。该方法被看作为原始 
PCA 
的鲁棒性版本，通过
去中值化对数据进行预处理，使数据在寻找特征时对异常更不敏感。常用的 
RPCA
的算法为 
Crux-Ruiz (CR)
。
 3  
基于正常行为模式的时间序列异常检测
 
45 
④
  
基于 
IPCA 
的异常检测。该方法是原始 
PCA 
的增量版本
[112]
。在线网络流
量的异常检测中，不断更新的新数据意味着原始的样本空间不断的被丰富。通过
新数据对特征向量和相应的权值进行更新，可以更好的描述标准网络流量的特征。
文献
[112]
介绍的更新算法虽然没有降低时间复杂度，但是降低了计算规模，提高了
算法的性能。
 
⑤
  
基于 
NNBP 
的异常检测。该方法通过对流量的预测实现异常检测。与基于
OMP 
的异常检测类似，该方法通过对预测值和实际值之间的误差的检测确定异常
点。
 
为方便比较，上述五种方法的运行过程与图 
3.1 
基本一致，即对初始数据段进
行数据清理和基函数生成得到一组基集合，面对新数据段的时候或者直接采用已
有的基（如基于 
OMP 
的检测）；或者直接生成新的基（如基于 
PCA 
和 
BP 
神经网
络的检测）；或者对已有的基进行更新（如基于 
IPCA 
的异常检测）。在本章提出的
框架下，为保证与在线异常检测的场景尽可能的一致，对后续新的数据段并不进
行异常清理。
 
我们包含上述五种方法的原因是为了尽可能多的将各类异常检测技术与
Basis Evolution 
进行比较。其中 
PCA
，
OMP 
等算法出现在大量的文献中，具有一
定的代表意义，且并不太过于复杂。例如我们没有选用基于小波的异常检测方法。
这是由于其需要调和的参数比较多。
 
3.4.1  
流量数据的合成
 
对流量数据进行仿真时要求生成的数据能够表现出流量数据的重要特征。故合
成的流量数据通常是真实流量数据的简化。由于合成数据的结构，生成异常的特
征是可控的，基于合成数据的实验便于对各类异常检测方法的性能进行评估分析。
 
数据的合成通常分为两步：首先生成标准流量，其次向标准流量中插入异常。
这里的标准流量是具有 
24 
小时周期的正弦函数生成的离散值序列，以表示流量数
据的强烈的周期性
[121]
。考虑到外界对真实流量的扰动，往合成数据中加入高斯白
噪声。假设无阻塞链路上的流量具有高斯性
[124]
，即在建模时不考虑数据之间的相
关性（尽管数据之间事实上是有相关性的）。这种建模方式考虑到了异常检测面对
的最坏情况：不具有相关性
[125]
。我们还对噪声的大小进行控制，例如满足标准正
态分布的噪声其幅值为标准流量大小的 
10%
。
 
合成的每个序列中包含 
8 
周共 
1344 
个数据，仿真每隔一个小时对流量数据进
行采样的情形。每个序列被分成四个数据段，其中第一个数据段作为初始数据段，
剩余三个数据段作为新数据段，以便于应用图 
3.1 
的异常检测架构。我们也试验了
其他长度的数据段，得到的结果基本相似，而以 
2 
周为每个数据段的长度（共 
4
个数据段）既便于算法实现，也能获得最好的检测结果。
 重庆大学博士学位论文 
46 
本章中的异常可以用模型 
A(

,

,

,

,

)
来表示，其中参数
 
，
 
，
 
，
 
和
 
用
于生成和插入异常。其中
 
表示异常的类别，这里异常的类别常用形函数（
Shape 
function
）来表示，宽度为 ，表示各异常类型的最小宽度（否则所有的异常崩塌
为 
spike
）。幅值 用于表示异常对于标准流量幅值的大小。常见的异常类型有：
 
①
  FIFD
（
(Fast  Increase, Fast Decrease
，
FIFD
），表示异常导致相应的流量快
速上升快速下降。作为经典的异常类型常用于各类异常检测中。这可能由于系统
或者设备运行中断或者 
Do S 
攻击导致的。
Spike 
作为最短的 
FIFD 
异常类型，是该
类中最常用的一种。
 
②
  SIFD (Slow Increase, Fast Decrease
，
SIFD)
，表示异常导致相应的流量先缓
慢的上升再快速下降。这可能是由于流行性网络攻击（如蠕虫病毒等）引起的。
其随时间流量缓慢的增加，保持在一定值再恢复到正常。
 
③
  FISSD (Fast Increase, stable State, Slow Decrease
，
FISSD)
，表示异常导致相
应的流量先快速的上升至某个值，并保持一段时间稳定的状态，再缓慢的下降。
这可能是由突发访问（
flash crowd
）引起的。例如网络上的热门话题会引起大量的
突发访问，直到到达一定的热度并持续一段时间后再失去热度回归正常。
 
④
  FISD (Fast Increase, Slow Decrease
，
FISD)
，这表示异常导致相应的流量先
快速的上升，再缓慢的下降。这种异常类型是 
FISSD 
的特例，即不存在稳定状态
的 
FISSD 
异常类型。
 
上述异常类型都包含了正负两个方向异常，即异常流量向上升和下降两个方
向的异常。为便于研究，设计生成的每个序列中只包含一种异常类型。由于其他
三类异常的实验结果和第一种异常类型是一样的，因此本章只针对第一种异常类
型 
FIFD 
进行了讨论。
 
参数
 
决定了插入的异常数目。设定
 
满足泊松分布

~ Poisson(

) 
，其中每个
数据段中
 
3
。这意味着每个生成的序列中平均被插入 
12 
个异常。
 
参数
 
决定了异常被插入的开始时间。理论上来说异常可以发生在任意时间，
而没有特定的偏好。因此设定参数
 
满足均值分布

~Uniform(0,b) 
，其中
b 
是数
据段的长度。
 
参数
 
用于改变异常的宽度，通常用 
 
表示每种类型下各异常的宽度，本
章试验中宽度控制参数
 
取值范围为
 
{0,4,10,20,40}
。
 
  
参数
 
用于更新异常的幅度，通常用 
 
来表示每种类型下各异常的幅度，本3  
基于正常行为模式的时间序列异常检测
 
47 
章试验中的幅度控制参数
 
的取值范围为
 
{0.1,0.3,0.5,0.7,1}
。
 
3.4.2  
异常检测的评价准则
 
当前异常检测技术使用的评价准则是精确度和误检率，即针对异常点的衡量指
标。基于实际应用的需求，本章对异常点进行了聚类，因此还需要对聚类的性能
进行评价。与精确度与误检率类似，针对异常类的一致性和敏感性提出了两组评
价准则。其中前者专注于衡量聚类中的点被正确分类的情况，而后者用于衡量类
中对于被错分类的点的包容情况。前者相当于精确度，后者相当于误检率。
 
将同一个原因产生的异常点聚集在一起成为一个异常类。对流量序列插入多个
异常类形成包含异常的流量序列。所有异常类构成了集合
c G 
，将异常类中的所有
异常点按照时间先后顺序排列集合在一起称为
G 
。在合成数据的实验中，这类数
据是有标记的。假设由异常检测算法 
r 
检查出的异常点的集合是
(r)
D 
，对其进行聚
类（算法如表 
3.3 
所示）得到
(r)
c D
。假设每个类对应着一个异常。
 
下述三组为试验中使用的评价准则：
 
①
  
针对异常点检测的评价准则是异常点检测概率（
Detection  probability  on 
anomalous points
，
DP_AP
）和误检率（
False-alarm probability on anomalous points
，
FAP_AP
）：
 
( )
    _
r
G D
DP AP
G

 
       （3.29
）
 
( ) ( )
 _   
r r
D G D
FAP AP
N
 
 
      （3.30
）
 
其中 
N 
是正常流量点的数目，而 
 
表示集合的大小。
 
②
  
第二组标准用于评价检测出的异常类是否属于真正的异常。任意一个类只
要包含真正的异常点，则定义其为“真正的异常类”（
Truly  detected  anomalies
）。
相应的评价准则被定义为异常类在数量上的一致性（
Consistency degree of anomaly 
groups  in  amount
，
CD_AA
）和异常类在数量上的聚合性（
Aggregation  degree  of 
anomaly groups in amount
，
AD_AA
）。假设检测到“真正的异常类”的数目为
( r)
c D
N 
，
而真正的异常类对应的真实异常类的数目为
( r)
c G
N 
，则
 
( )
_
r
c G
N
CD AA
c G
 
       （3.31
）
 重庆大学博士学位论文 
48 
( )
( )
_
r
c D
r
N
AD AA
c D
 
          （3.32
）
 
其中 
AD_AA 
记录“真正的异常类”对应的真实异常类占所有异常类的概率，
CD_AA 
用于衡量“真正的异常类”占所有检测到的类的概率。 
③
  
第二组评价标准使用了概念“真正的异常类”用于评价检测出的异常类是
否正确。这种评价标准非常简单，在第三组评价准则中，我们衡量“真正的异常
类”与其包含的真实异常点所在类的相互覆盖情况。一个“真正的异常类”中的
真实异常点可能来自于多个真实异常类，而真实异常类中的点可能散布于多个“真
正异常类”中。基于此，我们对纯度（
Purity index
）
[126]
进行扩展得到异常类在时
间上的一致性（
Consistency degree of anomaly groups in duration, CD_AD
）和异常
类在时间上的聚合性（
Aggregation degree of anomaly groups in duration, AD_AD
）
两个评价准则。主要对于检测方法检测到的真实数据点
(r)
x 

G 

D 
，我们定义
x
c G
是点 
x 
的真实所在类，而
( r)
x
c D 
是检测方法 
r 
检测到点 
x 
所在的类，对于每一个点 
x 
，
 
( )
_ ( )    
r
x x
x
c G c D
CD AD x
c G

 
     （3.33
）
 
( )
( )
  _ (  )
r
x x
r
x
c G c D
AD AD x
c D

 
     （3.34
）
 
通过均值化所有 
r 
检测到的真实异常点（即
(r)
G 

D 
的所有成员）的 
CD_AD
和 
AD_AD 
值，我们可以得到对方法 
r 
检测到的异常类的全局评价：
 
( )
( )
1
_ _ ( )
r
r
x G D
CD AD CD AD x
G D
 


 
    （3.35
）
 
( )
( )
1
_ _ ( )
r
r
x G D
AD AD AD AD x
G D
 


 
    （3.36
）
 
对于所有“真正的异常类”来说，
CD_AD 
是每个异常类的检测精度的加权均
值。
AD_AD 
是真实异常点在“真正的异常类”中所占比例的加权值。
 
我们通过控制正常边界的阈值 
q
（∈
[1.0,4.5]
），并生成相应的 
ROC
（
Receiver 
operator characteristics
）曲线图
[127]
，以分析六种检测方法的综合检测性能。
 
3.4.3  
实验结果和分析
 
对于合成数据，我们进行了四组实验。第一组实验比较异常（非 
Spike
）宽度
固定情况下的六种检测方法的性能。第二组实验考虑异常宽度变化对检测的影响。3  
基于正常行为模式的时间序列异常检测
 
49 
第三组实验比较了幅度值固定的情况下六种检测方法的性能。第四组实验考虑幅
度值的变化对检测的影响。每一组实验均按照上述包含异常的流量序列生成方式
生成流量，且每一个实验都重复 
100 
次。
 
①
  
宽度不变情况下的实验结果。
 
本实验向序列中插入幅值随机，宽度值不变（
 
10
）的多个异常类。实验结
果如图 
3.3 
所示。其中图 
3.3
（
a
）表示标准 
ROC 
曲线，异常点的精确率 
DP_AP 
和
误检率 
FAP_AP 
随着阈值参数 
q 
的增加而不断下降。观察图 
3.3
（
a
）六种算法在
DP_AP 
和 
FAP_AP 
之间的均衡，曲线越靠近图左上角表示其性能越好。值得注意
的是，本章提出的异常检测算法 
Basis Evolution 
要优于其他五种方法。表 
3.4 
给出
了更精确的比较结果。除了 
Basis Evolution 
本身的优越性之外，表 
3.4 
中当 
DP_AP
值为 
0.3 
时，
Basis Evolution 
得到一个非常低的 
FAP_AP 
值（低至 
0.0020
）。在海量
数据进行异常检验的过程中，低误检率能有效减少系统管理员的工作量，因此产
生低 
FAP_AP 
值的 
Basis Evolution 
在实际应用中具有很大的价值。
 
 
表 
3.4  
固定 
DP_AP
（
Detection probability on anomalous points
）值情况下，五种检测方法的
FAP_AP
（
False-alarm probabilities on anomalous points
）值。
DNE  
表示值不存在（
Does not exist
）。
注意到 
Basis Evolution 
中存在 
FAP_AP 
非常小的值。
 
Table 3.4 We fix the value of DP_AP, and report the corresponding FAP AP of 5 methods.DNE 
means “Does Not Exist”. Note that very small FAP_AP values are possible (shown in bold), as 
required. 
  
固定 
DP_AP 
方法
  0.3  0.5  0.6 
BE  0.0020  0.018  0.040 
OMP  0.025  0.16  DNE 
PCA  0.023  0.066  0.14 
RPCA  0.026  0.050  0.069 
IPCA  0.10  DNE  DNE 
NNBP  DNE  DNE  DNE 
 
图 
3.3
（
b
）呈现了“异常类在数量上的一致性 
CD_AA
（
Consistency degree on 
anomaly amounts
）”和“聚合性 
AD_AA
（
Aggregation degree on anomaly amounts
）”
的等价的 
ROC 
曲线图。随着阈值 
q 
的增加，
AD_AA 
上升，
CD_AA 
下降。观察图
3.3
（
b
）六种算法在 
CD_AA 
和 
AD_AA 
下的均衡，其中曲线越靠近图像的右上方重庆大学博士学位论文 
50 
意味着算法的性能越好。
Basis Evolution 
在 
q 
的所有取值范围内都比其他算法表现
的好。
 
  
图 
3.3
（
c
）随着阈值 
q 
增加，除了 
NNBP
，
IPCA
（以及 
PCA 
的最后一个点）
之外，其他算法在评价准则“异常类在时间上的一致性 
CD_AD
（
Consistency degree 
on anomaly duration
）”下降，而在“时间上的聚合性 
AD_AD
（
Aggregation degree on 
anomaly  duration
）”上升。观察该图在 
CD_AD 
和 
AD_AD 
上的均衡，发现曲线越
靠近图像右上方意味着相应算法的性能越好。在 
q 
的所有取值中，
Basis Evolution
比其他方法更优秀。
 
 
 
（
a
）
FAP_AP 
与 
DP_AP 
的 
ROC 
曲线图
 
 
（
b
）
CD_AA 
与 
AD_AA 
的 
ROC 
曲线图
 3  
基于正常行为模式的时间序列异常检测
 
51 
 
（
c
）
CD_AD 
与 
AD_AD 
的 
ROC 
曲线图
 
图 
3.3  
五种检测算法在检测 
FIFD 
类型异常时的性能。其中异常的宽度参数 
ψ = 10
，幅值随机。
FAP_AP 
是针对异常点的误检率。
DP_AP 
是对于异常点的精确度。
CD_AA 
和 
AD_AA 
分别是
异常类在数量上的一致性和聚合性，而 
CD_AD 
和 
AD_AD 
分别是异常类在时间上的一致性和
聚合性。
 
Fig.3.3 Performance of 5 methods for detecting FIFD anomalies. Here the width parameter isψ = 10, 
and magnitude is random. FAP_AP is the false-alarm probability on anomalous points. DP_AP is the 
detection probability probability on anomalous points. AD_ AA is the aggregation degree on 
anomaly amounts. CD_AA is the consistency degree on anomaly amounts. AD_AD is the 
aggregation degree on anomaly duration. CD_AD is the consistence degree on anomaly duration. 
 
②
  
宽度的变化情况下的实验结果。
 
测试异常检测算法的性能随异常宽度变化而变化的情况。插入的异常类的特征
是 宽 度 值 固 定 ， 而 幅 度 值 大 小 满 足 随 机 分 布 。 令 宽 度 参 数 依 次 取 值
 
{ 0 , 4 , 1 0 , 2 0 , 4 0 }
，得到 
Basis Evolution 
对不同宽度的异常进行检测的结果。图
3.4 
所示为 
Basis Evolution 
的第一对评价准则（
FAP_AP 
和 
DP_AP
）随宽度的变化
而产生的五条不同的 
ROC 
曲线。随着宽度的增加，
Basis Evolution 
的 
DP_AP 
越来
越低，而 
FAP_AP 
越来越高。类似的结果也出现在 
Basis Evolution 
的另外两组评价
准则中。因此随着宽度的增加，异常检测算法更难发现异常点和异常类，性能越
差。这一结论与期望相符合：当异常类的宽度增加时，流量中包含更多的异常点，
异常检测算法（如 
PCA 
等）在表示标准流量空间时会因此受到更多的影响。相应
的，异常检测的性能也随之降低。由此可知，异常类型 
spike 
最容易被检测出来，
而 
FISSD 
异常类型最难被检测出来。
 重庆大学博士学位论文 
52 
 
图
  3.4  
在不同异常宽度下用 
Basis Evolution 
检测 
FIFD 
异常类型的性能（用 
FAP_AP 
和 
DP_AP
衡量）。宽度的增加意味着异常越来越难以检测。由于第二和第三对的准则用于衡量性能时产
生相似的结果，故而只提供了第一对准则产生的图。
 
Fig.3.4 Performance for detecting FIFD anomalies with varying anomaly widths (FAP_AP versus 
DP_AP). Note that performance decreases with increase width. The additional plots are omitted as 
they reinforce the same results. 
 
③
  
幅度不变情况下的实验结果。
 
本组实验向序列中插入宽度随机，幅度不变（
 
0.5
）的多个异常类。三对评
价准则形成的（类）
ROC 
曲线图如图 
3.5 
所示。我们发现，几种检测方法的比较
结果与图 
3.3 
类似。以第一对评价准则产生的 
ROC 
曲线图为例，随着阈值 
q 
增加，
对异常点的检测精度 
DP_AP
（
Detection probability on anomalous points
）和误检率
FAP_AP
（
False-alarm probability on anomalous points
）也随之增加。因此靠近图片
左上方部分的曲线对应的算法具有更好的检测性能。由图 
3.5
（
a
）知，
Basis Evolution
比其他的算法更优秀。更精确的比较由表 
3.5 
可知。与表 
3.4 
相比，表 
3.5 
提供了
更好的结果。当 
DP_AP 
值固定为 
0.3 
时，
Basis Evolution 
的 
FAP_AP 
值为 
1.0
×
10
-4
。
 3  
基于正常行为模式的时间序列异常检测
 
53 
表 
3.5  
固定 
DP_AP
（
Detection probability on anomalous points
）值情况下，五种检测方法的
FAP_AP
（
False-alarm probabilities on anomalous points
）值。
DNE  
表示值不存在（
Does not exist
）。
注意到 
Basis Evolution 
中存在 
FAP_AP 
非常小的值
 
Table 3.5 We fix the value of DP_AP, and report the corresponding FAP_AP of 5 methods.DNE 
means “Does Not Exist”. Note that very small FAP_AP values are possible (shown in bold), as 
required. 
  
固定 
DP_AP 
方法
  0.3  0.5  0.7 
BE  1.0
×
10
-4
  0.0058  0.013 
OMP  0.0011  0.010  0.090 
PCA  0.014  0.042  0.16 
RPCA  0.038  0.088  DNE 
IPCA  0.044  DNE  DNE 
NNBP  DNE  DNE  DNE 
 
 
（
a
）
FAP_AP 
与 
DP_AP 
的 
ROC 
曲线图
 
 
（
b
）
CD_AA 
与 
AD_AA 
的 
ROC 
曲线图
 重庆大学博士学位论文 
54 
 
(c) CD_AD 
与 
AD_AD 
的 
ROC 
曲线图
 
图 
3.5  
五种检测算法在检测 
FIFD 
类型异常时的性能。其中异常的幅度参数
 
0.5 
，幅值随
机。
FAP_AP 
是针对异常点的误检率。
DP_AP 
是对于异常点的精确度。
CD_AA 
和 
AD_AA 
分
别是异常类在数量上的一致性和聚合性，而 
CD_AD 
和 
AD_AD 
分别是异常类在时间上的一致
性和聚合性。
 
Fig.3.5 Performance of 5 methods for detecting FIFD anomalies. Here the magnitude parameter is 
 
0.5 
, and magnitude is random. FAP_AP is the false-alarm probability on anomalous points. 
DP_AP is the detection probability probability on anomalous points. AD_ AA is the aggregation 
degree on anomaly amounts. CD_AA is the consistency degree on anomaly amounts. AD_AD is the 
aggregation degree on anomaly duration. CD_AD is the consistence degree on anomaly duration. 
 
④
  
幅值变化情况下的实验结果
 
最后一组测试中，我们研究了幅值的变化对异常检测算法性能的影响。这组实
验中插入的异常类的特征为幅值固定，宽度随机选择。幅值参数依次选择
 
{0.1, 0.3, 0.5, 0.7,1} 
，得到 
Basis Evolution 
对不同幅值的异常进行检测的结果。图
3.6 
所示为 
Basis Evolution 
的第一对评价准则（
FAP_AP 
和 
DP_AP
）随幅值的变化
而产生的五条不同的 
ROC 
曲线。随着幅值的增加，相应的 
FAP_AP 
值降低，而
DP_AP 
值上升。类似的结果也出现在 
BP 
的另外两对评价准则中。因此随着幅值
的增加，异常点和异常类更容易被检测到，各类异常检测算法的性能也随之升高。
这一结论是合理的：异常的幅值大，意味着异常点偏离的程度也越大，进而更容
易被检测出来。
 3  
基于正常行为模式的时间序列异常检测
 
55 
 
图
  3.6 
在不同异常幅值下用 
Basis Evolution 
检测 
FIFD 
异常类型的性能（用 
FAP_AP 
和
DP_AP 
衡量）。幅值的增加表示异常越来越容易被检测。由于第二和第三对的准则用于衡量性
能时产生相似的结果，故而只提供了第一对准则产生的图。
 
Fig.3.6 Performance for detecting FIFD anomalies with varying anomaly magnitudes (FAP_AP 
versus DP_AP). Note that performance increases with increase magnitudes. The additional plots are 
omitted as they reinforce the same results. 
 
3.4.4  
时间效率分析
 
本章的 
Basis Evolution 
框架包含数据清理，基函数生成，基函数更新和异常检
测四个部分。其中数据清理部分迭代的对异常数据进行检测（本文采用 
PCA  
和
NNBP 
算法）和填充，具有很高的时间复杂度。基函数生成部分基于 
SVD 
算法，
而原始的 
SVD 
算法复杂度高达 
O(N
3
)
。基函数更新部分的算法时间复杂度也达到
O(N
3
)
。异常数据检测中对异常点聚类的算法复杂度为 
O(N
2
)
。由于基函数生成，
基函数更新和异常点聚类的规模较小，故而后续三个部分真实所用时间远小于数
据清理的时间。
 
对于一个两周的数据段，基的更新平均（重复运行 
100 
次）需要 
0.6 
秒，而重
新生成基平均需要 
6.008 
秒。其中 
6 
秒是数据清理的时间，而 
0.008 
秒是基生成的
时间（使用 
Matlab 2012b 
运行在 
Mac OS X 10.9.5
，
  CPU 
为 
2.7GHz Intel Core i5
上）。由此实际应用中更倾向于用基函数的更新代替基函数的生成（包含数据清
理）。
 
 
3.5  
基于实际数据的实验及分析
 
本章使用真实流量数据集 
IIJ
（
Internet  Initiative  Japan
）
[128]
，其流量序列取自
于日本主干网上的路由器。数据持续时间为 
2014 
年 
4 
月 
4 
日到 
2014 
年 
12 
月 
4 
日。
它包含了 
10 
个链路上（出和入）的网络流量测量值，其中每个链路单方向上共有重庆大学博士学位论文 
56 
5857 
个样本。其采样间隔时间为 
1 
个小时。
 
真实流量时间序列中很难对异常数据进行标记。即使采纳专家的意见，流量时
间序列中仍然存在一些异常由于从没有见过而无法诊断。因此在对真实数据集的
检测和分析中，只能通过与已有的异常检测算法进行比较进而分析 
Basis Evolution
的性能。
 
具体的比较方法是：先选择一种已有的异常检测方法（例如 
PCA
）对 
IIJ 
进行
异常检测，将其检测出的异常点和异常类看作是“真实的”。再将 
Basis Evolution
和其他异常检测方法（如 
OMP
，
RPCA 
等）应用在 
IIJ 
上，并比较产生的结果。鉴
于 
NNBP 
和 
IPCA 
在 
3.4 
节的性能不好，故此处并不考虑这两个算法。
 
与 
3.4 
节合成数据类似，我们对每个链路单个方向的流量序列以两周为单位构
建数据段。按照图 
3.1 
对初始数据段进行数据清理和基生成的操作，而对后续数据
段进行基更新的操作。图 
3.7 
展示了由初始数据段得到的基集合，以及第二个数据
段得到的更新的基集合。从图 
3.7
（
a
）可以发现前两个基向量具有很明显的日和
周周期，而第三个基向量更多的包含了噪声。
 
 
(a)  
由初始数据段得到的初始的基向量集合，跨越时间：
2014 
年 
4 
月 
4 
日
-2014 
年 
4 
月
18 
日
 3  
基于正常行为模式的时间序列异常检测
 
57 
 
(b)  
对初始基向量进行更新得到第二个数据段的基集合
 
图
  3.7 IIJ 
中第二条链路的前两个时间段的使用的基集合。所有的基向量都经过 
z-score 
标
准化，使其均值为 
0
。
 
Fig.3.7 Basis vectors for the first two time segments of the second IIJ link. All functions are 
z-score normalized to have zero mean. 
 
  
本章实验中，将基于 
PCA 
检测出的结果作为“真实的”。图 
3.8 
表示了
Basis Evolution
，
RPCA 
和 
OMP 
三种算法寻找“真实的”异常的结果。
 
此处
  
“精确度”
DP_AP 
和“误检率”
FAP_AP 
与 
3.4 
节的意义不再相同，图
3.8 
表达的意义也有所不同：它主要表示算法之间的一致性。
RPCA 
与 
PCA 
具有最
高的一致性，即 
RPCA 
能够发现最大部分的“真实的”异常。而 
OMP 
和 
PCA 
最
不相似。
Basis Evolution 
在两者之间。
 
  
这种比较有什么价值？事实上，不同类型的算法能够从不同的侧面发现异常点
（或者类）。
OMP 
和 
PCA 
能够发现不同类型的异常，这正是我们所期盼的。对于
Basis Evolution 
来说，可能会发现其他算法不能发现的异常。为验证这个想法，我
们分别使用另外 
OMP
，
Basis Evolution 
的检测结果作为“真实的”异常，并检测其
他算法的性能。最终结果与图 
3.8 
类似，因此 
Basis Evolution 
并不能将“真实地”
异常完全检查出来，而其他算法也不能完全涵盖 
Basis Evolution 
的检测结果。我们
认为 
Basis Evolution 
可以发现其他算法发现不了的异常。
 
 重庆大学博士学位论文 
58 
 
图
  3.8  
算法在 
IIJ 
数据上进行异常检测的性能对比。将基于 
PCA 
检测出的异常看做“真实的”
异常。
 
Fig.3.8 Comparison of methods on the IIJ data. Anomalies detected by PCA are treated as ”real” 
anomalies. 
 
3.6  
本章小结
 
本章基于用户（或网络）的正常行为模式实现网络流量时间序列的异常检测。
通过基函数的生成和更新对正常流量进行表示，进而发现异常。这种异常检测的
方式不要求对异常有任何的先验知识，便于发现及检测新的异常类型。同时该方
法产生的误检率非常低，适用于在线应用。此外通过多检测器协同的方式进行数
据清理，能有效去除原始数据的异常点和噪声；而对检测结果进行聚类减少了网
络管理员的工作量，便于其分析异常产生的原因。
 
然而上述研究仍然有许多不足。由于 
Basis Evolution 
是基于网络流量的日周期
性寻找基函数，因此只适用于时间跨度为日级别以上的流量数据，而对于时间跨
度小于日级别的流量数据并不适用。此外基于 
SVD 
的基函数生成算法其复杂度为
O(N
3
)
，并不适用于大数据的情境，因此应当设计鲁棒性更强，复杂度更低（通常
以迭代的方式降低复杂度）的算法来替换 
SVD 
算法。同时 
Basis Evolution 
是基于
固定长度划分数据段的异常检测，即只能在固定时刻得到异常检测结果，而无法
在异常事件发生的时候及时检测并发现异常，因此 
Basis Evolution 
的一个重要改进
方向是能在随机时刻对任意长度的数据段进行异常检测，以实时的发现异常。
 
 
 
 
 
 4  
基于趋势预测模型的时间序列异常检测
 
59 
 
4  
基于趋势预测模型的时间序列异常检测
 
 
4.1  
引言
 
与第三章的思路一致，本章基于正常行为模式分析流量序列的特征，并对正常
网络流量进行建模。通过模型对未来网络流量进行预测进行异常检测。与第三章
不同的是，本章对流量预测和检测的时间尺度范围较广，例如 
1 
天或者 
1 
个小时，
而第三章对流量检测时间尺度是 
1 
天以上（实验中每隔两周进行异常流量检测），
因此二者应用的时间尺度不同。
 
作为预测精度较高的模型，
ANNs 
模型需要大量的样本和较长的时间构建模型
和训练参数，因此在实际应用中受到限制（特别是在线预测中）。针对该问题，本
章提出基于趋势预测模型的异常检测方法。
 
该方法通过用户（或网络）的正常行为模式，分析网络流量具有周期性特征和
短时相关性特征。基于上述特征设计了基于趋势的预测模型，并将结果用于异常
检测。基于趋势的预测模型在维持高预测精度的同时缩减了训练时间，且生成的
流量具有可解释性。基于趋势预测的异常检测模型具有较好的检测效果。
 
 
4.2  
相关理论研究
 
4.2.1 BP 
神经网络模型
 
BP 
神经网络是一种多层前馈网络（
Multilayer  feedforward  networks
），依据误
差反向传播进行参数修改以最小化输出与真实值之间的误差
[129]
。通常使用的误差
修正算法为梯度下降法。
 
BP 
神经网络作为有监督学习的一种，其输入的训练数据集应当是已标记的。
定义训练数据集为
 
1 1 2 2
( , ), ( , ),..., ( , )
q q
p t p t p t 
，其中
 
1 2
, ,...,
q
p p p 
是训练集的 
q 
个输
入，期望的输出是
 
1 2
, ,...,
q
t t t 
，而 
BP 
神经网络的最终实际输出是
 
1 2
, ,...,
q
o o o 
。
 
假设 
k 
表示 
BP 
神经网络的第 
k 
个输出层（k 


1,K
 
），
l 
表示为第 
l 
个隐含层
（l 


1,L
 
），对于单个训练样本
d
p 
来说，其从输入层到隐含层节点 
l 
的传递函数
为
l
f 
，而隐含层节点 
l 
到输出层节点 
k 
的传递函数为
kl
f 
，因此：
 
从输入到隐含层节点 
l
，
 
( )
l l l d
h 

f w p 
       （4.1
） 4  基
于趋势预测模型的时间序列异常检测 
60 
其中，
l
h 
表示了训练样本
d
p 
经过第 
l 
个隐含层节点的变换，通过传递函数
l
f 
计
算得到。
l
w 
为第 
l 
个隐含层节点相对于单个训练样本的权值。
 
从隐含层节点 
l 
到输出层节点 
k
，
 
( )
kl kl kl l
o 

f w h 
        （4.2
）
 
其中，
kl
o 
表示了第 
l 
个隐含层节点输出
l
h 
经过传递函数
kl
f 
到第 
k 
个输出层节
点的输出。
kl
w 
为输出层节点 
k 
相对于隐含层节点 
l 
输出
l
h 
的权值。
 
用 
BP 
神经网络进行学习的最终目标是最小化所有输出单元的误差。对任意一
个训练样本
d
p 
来说，其误差函数为
 
 
2
1
1
( )
2
K
d k k
k
E w t o

 

 
       （4.3
） 
其中
d
E 
表示训练样本
d
p 
的误差。
k
t 
表示训练样本
d
p 
期望由输出节点 
k 
给出的
输出，而
k
o 
表示
d
p 
实际经由输出节点 
k 
计算出的输出。
BP 
算法的目标是通过对误
差
d
E 
的反向传播修改各节点的权值 
w 
，从而达到训练误差最小化的目标。
 
BP 
神经网络学习中使用梯度下降法来更新权值。其假设前提为权值空间中的
误差是一个曲面，沿误差曲面最陡峭的方向下降可以找到使误差最小的点。而误
差曲面最陡峭的方向通常都是梯度向量的反方向。因此梯度下降法的训练法则为：
 
w 

w 
 
w         
（
4.4
）
 
其中 

w 
 
E(w) 
，η表示学习速率，是一个正的常数，表示梯度下降搜索
的步长。

E(w) 
表示误差对权向量的导数，由于 
BP 
神经网络存在多个输出节点和
多个隐藏节点，故分别计算权值对各节点的导数。
 
对于经过第 
l 
个隐含层节点到第 
k 
个输出节点的权值
kl
w 
，可以使用链式规则
推导其权值的改变量：
 
 
'
( )
k
kl kl k k kl l kl l
kl k kl
E Eo
w E w t o f h h
w o w
    
 
          
  
（
4.5
） 
其中
'
kl
f 
表示从第 
l 
个隐含层节点到第 
k 
个输出层节点的传输函数的导数。而对第4  
基于趋势预测模型的时间序列异常检测
 
61 
l 
个隐含层单元节点权值
l
h
w 
的变化可表示为：
 
 
' '
1 1
( )
K K
k l
l l k k kl kl l d l d
l
k 
k l l
k
E Eo h
w E w t o f w f p p
w o h w
    
 
  
          
   
 
（
4.6
）
 
其中
'
l
f 表示从输入节点到隐含层节点 l 
的传输函数的导数，
kl
 
和
l
 
分别被称做为
输 出 层 节 点 的 误 差 项 和 隐 含 层 节 点 的 误 差 项 ， 且
 
' ' '
1 1
K K
l k k kl kl l kl kl l
k k

t o f w f 

w f
 
 

 
 
。设置用作传输函数
kl
f 
和
l
f 
的非线性函数为
sigmoid 
函数，进而输出层节点和隐含层节点的权值的改变可表示为：
 
 
'
(1 )( )
kl k k kl k k k k
 
t 

o f 

o 

o t 

o 
      （4.7
） 
1
(1 )
K
l l l kl kl
k

h h w 


  
 
       （4.8
）
 
kl kl l
w 

h 
         （4.9
） 
l l l

w 

h 
         （4.10
） 
kl kl kl
w 

w 
 
w 
        （4.11
） 
l l l
w 

w 
 
w 
        （4.12
） 
由此我们得出 
BP 
神经网络算法步骤为：
 
①
  
初始化所有网络节点的权值；
 
②
  
前向传播训练样本，并根据公式（
4.1
）和（
4.2
）计算每个节点的输出；
 
③
  
反向传播误差，根据公式（
4.7
）和（
4.8
）依次计算输出层节点和隐含层
节点的误差项；
 
④
  
根据各节点的误差更新误差的权值，其中根据公式（
4.9
），（
4.10
），（
4.11
）
和（
4.12
）依次计算出输出层节点和隐含层节点的权值的改变量，并对权值进行调
整。
 
BP 
神经网络尽管有广泛的应用，但还是具有很多局限性：
 
①
  
算法收敛速度慢。由于参数学习速率的设置问题，过小的学习速率会降低
收敛速度，过大的学习速率可能导致误差一直在最优解附近震荡。通过将学习速
率进行自适应的调整或者在对权值进行梯度变化时添加一个动量因子。
 
②
  
难以确定神经网络的结构。
ANNs 
是基于工程的算法，其输入层，隐含层4  基
于趋势预测模型的时间序列异常检测 
62 
和输出层的数目以及相应的节点数通常由经验来确定，并没有一个可以依赖的标
准。而神经网络的结构决定了模型的性能。常用的结构确定方法是基于剪枝的方
法，主要通过计算节点输出的相关性，判断是否存在冗余节点
[130]
。
 
③
  
易陷入局部最优。由于 
BP 
神经网络中包含的节点数较多，相应的由权值
构成的空间维度也很高。高维空间下的误差曲面将会有多个局部最优值。采用梯
度下降算法可能最终得到的是局部最小误差值而非全局最优解。启发式算法可以
协助梯度下降算法从整个解空间中搜索近似最优解
[131]
。
 
4.2.2 Hodrick Prescott  
趋势提取模型
 
HP 
模型首次用于分析战后美国经济周期
[132]
，该方法假设经济时间序列
t
y 
包含
趋势成分
t
x 
和波动成分
t
c 
，则
 
t t t
y 

x 

c                         
（
4.13
）
 
其中
t 

[1, ,n]
，则 
HP 
趋势滤波算法目标就是从
t
y 
中提取
t
x 
。
 
HP 
的趋势提取问题可被定义化为公式（
4.14
），
 
1
2 2
1 1
1 2
1
( ) (( ) ( ))
2
n n
t t t t t t
t t
min f min y x 

x x x x

 
 
 

  

   
  
（
4.14
）
 
其中第一项表示了原始流量和相应趋势之间的差异，而第二项用于保证趋势的光
滑度。这里参数
 
表示了系统在构建趋势逼近实际序列和对趋势进行平滑之间的权
衡。当

=0
时，上述问题的解为
t t
x 

y 
，当 
 
增加时，趋势中的变化慢慢变弱，即
 
越大，估计出的趋势越光滑。
 
定义二阶差分矩阵为
(T2) (T)
D R
 
 
，其中
,
1
t t
D 
 ,
 
, 1
2
t t
D

  
, and 
, 2
1
t t
D

 
，则
HP 
模型为趋势 
x 
取得的闭式解为：
 
1
(1 2 )
T
x 

D D y

  
       
（
4.15
）
 
其中
1
[ , , ]
T
T
y 

y 

y , 
1
[ , , ]
T
T
x 

x 

x 。 
HP 
系列模型被广泛的应用于各个领域，如经济学中经济周期的研究
[133,  134]
，
现货价格变化建模
[135]
；社会学中社交媒体话题建模
[136]
等。
 
为了扩大 
HP 
模型的使用范围，将公式（
4.14
）中的第二项替换为
1
范式的形
式，以获得分段的线性趋势。这种分段的线性趋势使 
HP 
模型可用于近线性甚至非
线性的序列中
[137]
。经典 
HP 
模型对时间序列中各点的平滑是等价的，对于存在较4  
基于趋势预测模型的时间序列异常检测
 
63 
多突发性的时间序列来说，这种等价式的平滑使其丢失了重要的细节信息，因此
需要根据序列当前的状态判断对趋势进行光滑的程度。
 
文献
[138]
提出迭代式加权的启发式算法，通过对模型的复杂性和
1
范式加权判
断趋势应该被光滑的程度。这种情况下，模型产生了更低的均方差 
NMSE
（
Normalised mean square prediction error
）。受该方法的启发，文献
[139]
提出了一种
基于高斯混合的 
HP 
模型，该模型的趋势在时间序列剧烈变化的地方保留了较复杂
的较具体的特征，而在其他地方则比较光滑。
 
 
4.3  
基于趋势预测模型的流量时间序列异常检测
 
4.3.1  
问题的定义和解决方案分析
 
基于趋势的流量预测要解决的问题有：
 
①
  
基于趋势对流量时间序列进行预测。
 
用户（或网络）在短时间内使用的网络应用具有较强的关联性，例如视频服务
能延续较长的时间；浏览器服务中，用户新打开的页面通常与当前的网页具有相
关性。基于此，用户的正常行为模式会导致短时间内流量数据具有很强的相关性，
即流量具有相关结构特征。此外，由 
3.3 
节可知，网络流量时间序列还具有很强的
周期性特征。
 
基于流量序列的周期性和短时相关性提出基于趋势的流量预测方法。其中流量
的趋势由周期趋势和相关趋势组成。周期趋势包含流量的周期性成分，而相关趋
势体现了流量数据的相关结构特征（流量的短时相关性通常会导致周期内的流量
具有结构特征，我们称之为相关特征。趋势内通常保留周期内较明显，时间尺度
较大的相关结构特征）。原始流量和趋势之间的残差可看作内外各种因素对趋势的
扰动。因此对流量时间序列的预测包含对周期趋势，相关趋势和扰动的分别预测。
 
②
  
设计预测结构。
 
定义一条链路上的流量序列
1
[ ,..., ]
N
y y 
，其采样时间序列为
[0,

,T] 
。将其转换
为矩阵形式
TR(J,I)
，
 
1 ( 1) 1 ( 1) 1(1,1) (1, )
( 1) ( 1)( ,1) ( , )
( ,1) ( , )
i J I Ji
j i J j I J jj j i
J i J IJJ J i
y y ytr tr
TR y y ytr tr
y y ytr tr
   
   
         

     
    

     
    


     

   

     
   

     
   

     
   
        
(1, )
( , )
( , )
I
j I
J I
tr
tr
tr
  
 
 
 
 
 
 
 
  
 
  
 
  
 
（
4.16
）
 
其中每一列包含 
J 
个测量值，持续时间为 

t 
。通常

t 
为一天或者一周。一共4  基
于趋势预测模型的时间序列异常检测 
64 
有列数
T
I
t


（
T 
通常为 

t 
的整数倍）。因此 
TR 
的每一列是长度为

t 
的流量序列，
每一行是等间隔流量序列，其时间间隔为 

t 
。
 
网络流量的预测问题被描述为已知大小为
Q 
的流量序列
1
[ ,..., ]
Q
y y 
，预测未来
N 

Q 
个流量数据
1
[ ,..., ]
Q N
y y

，这里我们考虑当
Q 

J 
且
(N 

Q) 

J 
的情况。在这
种设定下，
TR 
的前 
I 

1
列的值是已知的，第 
I 
列中的前 
q 
个数据是已知的，
q 

Q 

(I 

1)J 
。第 
I 
列中的后 
J 

q 
个数据是未知的需要被预测的。这里我们有
(I 

1) 

mod(Q/ J)
，及 
J 

q 

N 

Q 
。
 
定义 
TR 
的趋势矩阵为
( , ) 1 ,1
[ ]
j i i I j J
TT tt
   
 
，
由于流量序列的趋势保持网络流量
的短时相关性和周期性。由上述定义知，对于第 
I 
列剩余 
J 

q 
流量趋势的预测可
以分成两个部分，一部分根据等间隔时间序列评估其周期趋势，即行预测，另一
部分基于已知的 
q 
个数据预测其相关趋势，即列预测。而对扰动预测的结构与相关
趋势的类似，都属于列预测。
 4  
基于趋势预测模型的时间序列异常检测
 
65 
图 
4.1 
第 
I 
列剩余 
J 

q 
个元素的趋势预测结构。
Q 
个已知数据形成了一个矩阵，其中第 
I 
列
中后 
J 

q 
个元素是未知的。块 
1 
是子矩阵
( , ) [1, ], [ , 1]
[ ]
j i j q i I n I
tt
   
。块 
2 
是列向量
( , ) [1, ]
[ ]
j I j q
tt

。
块 
3 
是子矩阵
( , ) [ 1, ], [ , 1]
[ ]
j i j q J i I n I
tt
    
。块 
4 
是列向量
( , ) [ 1, ]
[ _ ]
j I j q J
pr tt
 
。块 
1 
和块 
3 
构成了相
邻的 
n 
列。块 
4 
的所有元素都需要被预测，块 
2 
与块 
4 
在同一列。块 
2 
的相关趋势可通过块 
1
进行评估，并可用于预测块 
4 
的相关趋势。块 
3 
可用于评估块 
4 
的周期趋势。
 
Fig.4.1 Trend prediction structure of  
J 

q 
  elements in column  
I 
. Trend of  
Q 
  historical data 
forms a matrix, in which the last  
J 

q 
  elements in column  
I 
  are unknown. Block 1 is a 
submatrix 
( , ) [1, ], [ , 1]
[ ]
j i j q i I n I
tt
   
. Block 2 is a column vector 
( , ) [1, ]
[ ]
j I j q
tt

. Block 3 is a submatrix 
( , ) [ 1, ], [ , 1]
[ ]
j i j q J i I n I
tt
    
. Block 4 is a column vector 
( , ) [ 1, ]
[ _ ]
j I j q J
pr tt
 
. Block 1 and Block 3 
compose the neighboring n columns. All elements in Block 4 need to be predicted, while Block 2 
shares the same column with Block 4. The relative trend values of Block 2 are estimated with Block 
1, and can be used for predicting the relative trend of Block 4. Block 3 is to predict the periodical 
trend of Block 4.  
 
如图 
4.1 
所示，第 
I 
列被分为两块：块 
2 
和块 
4
。
I 
中元素的周期趋势可通过对
相应行的已知等间隔时间序列
( ,1) ( , ) ( , 1)
[ , , , , ]
j j i j I
tt tt tt

  
进行处理得到。由于用户（或4  基
于趋势预测模型的时间序列异常检测 
66 
网络）的正常行为模式变化的比较缓慢，因此只需要行相邻的数个趋势值
( , ) ( , 1)
[ , , ]
j I n j I
tt tt
 
 
（ 
n 

I 

1
）即可进行周期趋势预测。图 
4.1 
中块 
1 
用于评估块 
2
的周期趋势，而块 
3 
用于评估块 
4 
的周期趋势。
 
第 
I 
列的周期趋势表示为
( , ) 1
[ _ ]
j I j J
ar tt
 
，
  
块 
2 
在得到周期趋势后，计算相关
趋势
( , )
_
j I
l tt 
，并基于 
ANNs 
算法对块 
4 
的相关趋势进行预测。与相关趋势的预测
类似，基于块 
2 
的扰动，利用 
ANNs 
算法对块 
4 
的扰动进行预测。
 
因此设计对块 
4
（第 
I 
列 
J-q 
个未知元素）的预测结构为：块 
3 
评估块 
4 
的周
期趋势，块 
2 
评估块 
4 
的相关趋势和扰动。
 
③
  
设计预测流程图。
 
图 
4.2 
是整个预测过程的流程图。其中 
TR 
采用公式 
( ) / ( )
min max min
x
 
x 

x x 

x 
归
约到
[0
，
1]
范围。在提取趋势之后，只需要计算块 
1 
和块 
3 
的趋势值，即可得到块
2 
和块 
4
（列 I ）的所有周期趋势值（周期趋势评估）。计算块 2 
的相关趋势可以预
测块 
4 
的相关趋势（相关趋势预测）。计算块 
2 
的扰动可以预测块 
4 
的扰动（扰动
预测）。对评估的周期趋势，预测的相关趋势和扰动整合可以得到最终的预测值。
 
为保证预测的精度，对相关趋势和扰动的预测均采用 
ANNs 
模型。由于基于
ANNs 
的算法需要训练的样本数远远大于输出的数目，通过“
k 
值预测”的方法来
减小样本数不足带来的影响：设定一个大小为 
q 
的窗口，并用其预测相邻的 
k
（ 
k 

q 
）个值；再将窗口滑动到下一个 
q 
窗口，继续预测相邻的 
k 
个值；重复上
述过程直到所有 
J 

q 
的相关趋势值都被预测。在这种情况下，总的输出数 
J 

q 
可
能会大于原始输入数 
q 
，例如当 
J 

300 
时，输入 
q 

60 
， 
k 

10 
，而最终输出为
J 

q 

240 
。图 
4.3 
以相关趋势的预测为例，展示了“
k 
值预测”的过程，在时间
c 

[q,

, q 

(m 

1)k,

, q 

(M 

1)k]
处，“
k 
值预测”过程被依次激发。其中
 
(( ) ) -1 mod( ) 0;
=
(( ) ) .
J q k if J q k
M
J q k otherwise
  
 




 

   （4.17
）
 
我们将这种“
k 
值预测”的过程叫做元预测（
Meta prediction
），最终可获得所有 
J 

q
个相关趋势。
 
流程图 
4.2 
显示了利用元预测得到所有 
J-q 
个元素的预测值的过程。值得一提4  
基于趋势预测模型的时间序列异常检测
 
67 
的是，由于采用了元预测方式，每次迭代都需要学习 
q 
个列相邻相关趋势（或扰
动）值以预测列 
I 
中未知的 
k 
个元素的相关趋势（或扰动）值。而这 
q 
个相关趋势
（或扰动）值则来自于对 
nq+q 
个原始流量值的处理（其中 
q 
为 
k 
个未知点的列相
邻数据，而 
nq 
为该 
q 
个点的相应行相邻数据）。
 
由于对列 
I 
中每个元素的周期趋势的评估仅需要行相邻的 
n 
个行相邻的趋势
值。因此对未知 
k 
个流量的周期趋势的预测需要 
nk 
个行相邻数据点。
 
故本章提出的预测方法在元预测的训练阶段要求输入
(k+q)n+q 
个原始流量数
据。经过处理后得到 
q 
个数据直接作为输入用于神经网络的训练，因此缩短了模
型的训练时间，提高了算法的预测精度。
 
在接下来的节中详细的介绍流程图中的成分，其中 
4.3.2 
节介绍趋势提取，
4.3.3
节介绍周期趋势评估，
4.3.4 
节介绍相关趋势预测，
4.3.5 
介绍扰动预测，
4.3.6 
节介
绍数据整合。
 
 
 
图 
4.2  
对矩阵 
TR 
中第 
I 
列中未知 
J 

q 
个元素预测的流程图。
TR 
先被归一化至
[0
，
1]
范围，
然后经过趋势提取过程提取趋势。流量的预测被分解为三个部分：周期趋势评估，相关趋势
预测和扰动预测。周期趋势评估对行相邻 
n 
个向量进行计算，相关趋势预测和扰动预测都建
立在元预测基础之上。元预测的触发时间序列为
c 

[q,

,(m

1)k 

q,

,(M 

1)k 

q]
. 
Fig.4.2 The flow chart of traffic prediction framework for unknown  
J 

q 
  elements in column  
I 
 4  基
于趋势预测模型的时间序列异常检测 
68 
of matrix TR. TR should be cleaned first using data sanitisation process, then be extracted with trend 
extraction process. The prediction of traffic measurements should include three parts: periodical 
trend estimation, relative trend prediction and residual prediction. Periodical trend estimation 
proceeds on the neighboring trend values in row instead of the whole historical data. Both relative 
trend prediction and residual prediction apply meta prediction mechanism against the training size 
requirement of ANNs-based prediction algorithm. The meta prediction process is triggered at time 
index series  
c 

[q,

, (m 

1)k 

q,

, (M 

1)k 

q] 
. 
 
图 
4.3 
第 
I 
列中基于前 
q 
个趋势对剩余 
J 

q 
个流量值的相关趋势预测。元预测过程需要重复
M 
次。在任意一个触发时间 
c 

q 

(m 

1)k 
，根据 
q 
个相关趋势（时间从 
q 

(m 

1)k 

1
到
q 

(m 

1)k 
）预测相邻的 
k 
个相关趋势值（时间从 
q 

(m 

1)k 

1
到 
q 

mk 
）。整个处理过
程也适用于扰动预测。
 
Fig.4.3 Relative trend prediction on the rest 
J 

q
  traffic values using known 
q
  elements in 
column 
I 
. The meta prediction process has to be repeated  
M 
  times. At any trigger time 
c 

q 

(m 

1)k
, we predict 
k
  values from time index 
q 

(m 

1)k 

1
  to 
q 

mk
, given 
neighbouring 
q
  relative trend values (from 
(m 

1)k 

1
  to 
q 

(m 

1)k
). The whole process is 
also fit for residual prediction 
 
4.3.2  
趋势提取
 
正常的用户（或网络）行为模式导致了网络流量具有周期性和短时相关性，因4  
基于趋势预测模型的时间序列异常检测
 
69 
此提取的趋势必须具有这两种特性。基于经典的 
HP 
模型
[132]
，流量序列的趋势提
取被描述为下述最优化问题：
 
1
2 2
1 1,* ,* ,* 1,* 2 *, *,
1 1 2 1
1
( ) ( ) (( ) ( )) ( )
2
I J J I
T
ji ji j j j j i ii i
i j j i
min f tt min tr tt 

tt tt tt tt 

tt l tt

 
   
 

  

    

  
（
4.18
）
 
其中
ii
l 
为矩阵 
L 
的元素，且
1 

i 

I 
。定义 
L 

diag(sum(DIS)) 

DIS 
，其中 
DIS 
记
录了 
TR 
中列与列之间的距离：
 
2
1
( )
( , ) ( )
J
ji ji
j
tr tr
DIS i i exp
N



 

     
（
4.19
）
 
DIS(i,i
’
)
衡量了第
th
i 
和第 
( )
th
i
 
列之间的距离， 
N 
是个常量，使距离值能落在预定的
范围内。设已有的最大流量值为 
MAX
，最小流量值为 
MIN
，则 
N 
通常为大的基
数，以限制 
DIS 
的范围。矩阵的每一列代表了一天或者一周，因此距离 
DIS 
衡量
了天与天或者周与周之间的差距，而矩阵 
L 
主要用于惩罚 
TR 
列之间的距离或不相
似性。 
公式（
4.18
）中，第一项最小化重构误差，第二项惩罚了趋势矩阵 
TT 
中列方
向的变化，以平滑的方式获得每列的趋势，保存了每列影响力较大的相关结构，
第三项惩罚了列与列之间的不相似性以保证提取的趋势具有周期性特征。参数
1

和
2
 
分别用于均衡第一项与第二和三项。将公式（
4.18
）写成矩阵形式有：
 
2
1 2
1
( ) ( ) ( ) ( )
2
T T
min F TT 

TT 

TR 

D 

TT D 

TT 

tr TT 

L 

TT   
（
4.20
）
 
其中tr()表示矩阵的迹，
( J2) J
D R
 
 
，
 
,
1
j j
D 
 
，
, 1
2
j j
D

  
，
, 2
1
j j
D

 
。
 
块 
3 
构成的矩阵
*, *, 1
( ) [ , , ]
I n I
TR J n tr tr
 
   
用于提取趋势和计算块 
4 
的周期趋
势，块 
1 
和块 
2 
构成的矩阵
, , 1
( ) [ ,..., ]
j I n j I j q
TR q n tr tr
  
  
用于提取趋势和计算块 
2
的相关趋势和扰动。为叙述方便，公式（
4.20
）中仍然使用TR(J,I)来表示所用的
矩阵。
 
使用梯度下降算法来求解（
4.20
）得：
 
1 2
2 2 0
T
d F
TR TT D D TT TT L
d TT
         
    （4.21
）
 
上述公式是一个 
Sylvester 
方程，相应的解为：
 4  基
于趋势预测模型的时间序列异常检测 
70 
1 2
(( 2 ) (2 ))
T
J I J
I 

D D 

I 

I 


L TT 
 
TR
     （4.22
）
 
其中

  
是 
Kronecker 
乘积，
J
I 
和
I
I   
分别是大小为 
J 

J   
和 I 

I 的单位矩阵。 
4.3.3  
周期趋势评估
 
提取趋势之后，列 
I 
的周期趋势被表示为行相邻趋势的加权平均：
 
( , ) 1 ( , 1)
( , )
1
_
I n j I n I j I
j I
I n I
w tt w tt
ar tt
w w
   
 



     （4.23
）
 
其中
1

j 

J 
， 
n 

I 

1
，且
1
[ , , ]
I n I
w w
 
 
  
是权值集合。
 
由于用户（或网络）的正常行为模式是不变或者是缓慢变化的，因此很小的 
n
个行相邻的趋势即可评估周期趋势，实验中令 
n=4
。假设离列 
I 
越近的趋势值在计
算周期趋势的时候贡献越多，相应的权值也越大，因此在后续试验中，权值向量
4 3 2 1
[ , , , ]
I I I I
w w w w
   
的一个取值组合为
[0.5, 0.5, 1, 1]
。
 
4.3.4  
相关趋势预测
 
块 
2 
在得到周期趋势后，可以计算其相关趋势。一种方法是将相关趋势看作趋
势和相应周期趋势的差异：
 
( , ) ( , )
( , )
( , )
_
_
_
j I j I
j I
j I
tt ar tt
l tt
ar tt

 
       （4.24
）
 
其中
1

j 

q 
。
 
周期趋势描述了网络流量的长期特征，然而对于每天或周内的流量序列来说，
其流量模式是不完全相同的，这通常由流量数据的相关性决定。因此相关趋势的
预测只能用列相邻的值进行预测。
 
图 
4.4 
表示了相关趋势预测在触发时间 
c 
的处理过程。它主要包含两个部分：
对列相邻的 
q 
个流量的相关趋势评估，以及基于 
ANNs 
对 
k 
个流量的相关趋势进
行预测。在触发时间 
c
，第一部分的相关趋势评估生成了[c 

q 

1,c]时间段的相关
趋势
( , ) 1
[ _ ]
j I c q j c
l tt
   
。第二部分使用 
BP 
神经网络算法预测时间区间[c 

1,c 

k]的
相关趋势
( , ) 1
[ _ _ ]
j I c j c k
pr l tt
   
。整个迭代过程被触发了 
M 
次后，得到所有 
J-q 
个未
知流量的相关趋势预测值：
 
( , )
_ _
j I

pr l tt 
        （4.25
）
 
其中c 

1

j 

c 

k ，且c

{q,

,q 

(m

1)k,

,q 

(M 

1)k}。 4  
基于趋势预测模型的时间序列异常检测
 
71 
 
图 
4.4  
触发时间为 
c 
时相关趋势的预测过程
 
Fig.4.4 Relative trend prediction process which is triggered at time index c. 
 
4.3.5  
扰动预测
 
扰动被定义为原始网络流量和相应趋势之间的差异（
( , ) 1 ,1
[ ]
j i i I j J
RE re
   
 
）：
 
( , ) ( , )
( , )
( , )
j i j i
j i
j i
tr tt
re
tt

 
       （4.26
）
 
对扰动的预测是为了修正周期趋势评估和相关趋势预测产生的误差，使最终的
预测的流量值尽可能接近原始流量值。与相关趋势的预测过程类似，扰动的预测
也采用了元预测的机制，以放宽对于输入样本数的要求。
 
与 
4.3.4 
节类似，
ANNs 
神经网络根据列相邻的 
q 
个已知的扰动值预测 
J-q 
个未
知流量的扰动值，图 
4.5 
表示了扰动预测的处理过程。它主要包含两个部分：对已
知的列相邻的 
q 
个流量的扰动值的计算和基于 
ANNs 
预测未来 
k 
个流量的扰动值。
在触发时间 
c
，第一部分计算从时间c 

q 

1到c 
的扰动
( , ) 1
[ ]
j I c q j c
re
   
；而第二部分，
ANNs 
同样选择 
BP 
神经网络算法预测时间区间 [c 

1,c 

k]中 k 
个流量的扰动
( , ) 1
[ _ ]
j I c j c k
pr re
   
。整个迭代过程被触发了 
M 
次后，得到所有 
J-q 
个未知流量的相
关趋势预测值为：
 
( , )
_
j I

pr re 
        （4.27
）
 
其中c 

1

j 

c 

k ，且c

{q,

,q 

(m

1)k,

,q 

(M 

1)k}。 4  基
于趋势预测模型的时间序列异常检测 
72 
 
图 
4.5  
触发时间为 
c 
时的扰动预测过程
 
Fig. 4.5 Residual prediction process which is triggered at time index c 
 
4.3.6  
所有预测评估值的整合
 
周期趋势表示了正常网络流量的周期性，而相关趋势表示了网络流量的相关结
构特征。因此趋势的预测值是对周期趋势的评估和相关趋势的预测的综合，因此
对于流量未知的列 
I 
的剩余 
J-q 
个元素来说，评估的流量趋势为
 
( , ) ( , ) ( , )
_ (1 _ _ ) * _
j I j I j I
pr tt 
 
pr l tt ar tt      
（
4.28
）
 
其中 q 

1

j 

J 。 
扰动用于修正趋势与原始流量之间的差异，使最终对流量的预测值尽可能的接
近原始流量值。因此对于流量未知的 
J-q 
个元素来说，其趋势评估值可以通过扰动
预测值进行调整进而得到最终的流量预测值为：
 
( , ) ( , ) ( , )
_ (1 _ ) * _
j I j I j I
pr tr 
 
pr re pr tt       
（
4.29
）
 
由上述两个公式可知，流量预测中，周期趋势评估和相关趋势预测用于确认趋
势值，扰动预测用于对趋势的修正。
 
4.3.7  
基于预测的流量时间序列异常检测
 
根据公式（
4.29
）得到最终预测的 
J-q 
个流量值，计算实际值和预测值之间的
误差
( , ) ( , ) ( , )
_
j I j I j I
r 

tr 

pr tr 
，采用基于阈值的方式对误差进行检测发现异常点。对
于任意误差 
r ,  
我们设置其上下限为
[p 

q*

, p 

q*

]
，其中 
p 
和
 
表示
r 
的均值
和标准差。参数 
q 
用于设置不同大小的边界，进而可以计算对异常的检测精度和误
检率。
r 
中任意的点如果落在限定的边界之外，便被认为是异常的。同 
3.4 
节一样，
参数 
q 
的范围为
[1.0
，
4.5]
以便于全面的评估异常检测方法。
 4  
基于趋势预测模型的时间序列异常检测
 
73 
4.4  
小时间尺度下流量时间序列的相似性分析
 
流量的周期性导致了矩阵 
TR 
中相邻的列之间具有相似性（设计 
TR 
的每列表
示的时间跨度 

t 
是一天或一周），然而对于在小时间尺度下（如分钟级，秒级，毫
秒级）收集的流量序列来说，使用应用的相关性导致了 

t 
很小的时候，列之间也
具有很强的相似性。这一结论已经通过对时长为一个小时的数据集
'DEC-PKT1'
[36]
进行了验证。该数据集的采样单位是 
0.1 
秒。
 
  
将流量序列转化为矩阵 
TR
，每一列代表的时间段 

t 
为 
1 
秒或者 
1 
分钟，计算
列与列之间的修正余弦相似度可得小时间尺度下列之间的关系。图 
4.6 
表示随着时
滞（
Time lag
）的增加，列与列之间的平均相似度的变化情况。当

t 
为 
1 
秒时，如
图 
4.6
（
a
）所示，约 
92%
的平均时滞相似度在 
 
c*
 
范围内，其中 
 
0.97 ，
 
0.0034 
，
c=1.64 
表示标准正态分布情况下分位数为 
0.95 
时的值。当 

t 
为 
1 
分
钟时，由图 
4.6
（
b
）可以发现约有 
6 
个点在 
 
c*
 
范围之外，其中 
 
0.86 且
 
0.0076 
。
 
  
因此流量时间序列无论是在 
1 
秒钟或者 
1 
分钟的时间段，都与不同时滞的时间
窗口的流量序列呈现相似性。这种小时间尺度下的相似性表明趋势提取的公式
（
4.15
）可以直接用于小时间窗口的数据中。因此本章提取的流量预测架构可以直
接用于短时间尺度下的流量序列。
 
 
 
 
图 
4.6  
每种时滞下序列
’DEC-PKT1’
的平均相似度。单位时滞大小为（
a
，
upper
）
1 
秒（
b
，
down
）
1 
分钟。
 
Fig.4.6 Average similarity of traffic series in each time lag in trace 'DEC-PKT1'. The size of each 
time lag is (a),1 second (upper) and (b),1 minute (down). 4  基
于趋势预测模型的时间序列异常检测 
74 
4.5  
基于真实数据集的实验评估和分析
 
当前对流量数据的异常检测通常使用的公开数据集有 
Abilene
，
Geant
，
Caida
和 
lbl 
等。其中 
Abilene 
和 
Geant 
数据集以 
5min 
或者 
15min 
为单位对美国和欧洲的
主干网数据进行收集，其时间跨度通常在月以上。
Caida 
数据集和 
lbl 
数据集分别
来自于美国 
Caida 
组织和 
Larwence  Berkeley 
实验室，其数据集收集单位为毫秒级
以下，时间跨度在一个小时左右。根据时间尺度的不同，基于趋势预测的流量异
常检测模型选择了广泛使用的分钟级时间尺度下的
Abilene
数据集和毫秒级时间尺
度下的 
lbl 
数据集进行实验验证。本章使用 
lbl 
数据集中的
'DEC-PKT1' trace
，每隔
1 
毫秒进行一次采样，包含 
1 
个小时的数字设备公司和外界的通信状况。数据集记
录了每个 
TCP 
数据包的源 
IP
，目的 
IP
，源端口，目的端口和大小；另一个 
Abilene[140]
数据集是包含了 
12 
个节点研究性主干网络，横跨了全美国采用 
Internet2 
架构的大
学和实验室。在 
Abilene 
中，每隔 
5 
分钟进行一次采样。我们随机选择 
5 
条链路进
行实验验证。
 
首先将所有的流量序列转换为矩阵形式，对于流量序列
'DEC-PKT1'
的矩阵，其
每一列为 
1 
分钟的流量序列，包含
  J=600 
个流量值，一共有 
60 
列。对于 
Abilene
中的链路流量构成的矩阵，其每一列含有 
J=288 
个流量值，跨越的时间范围为 
24
小时。
 
进行周期趋势预测的时候，行相邻的 
n=4 
个流量趋势值要求已知，因此整个流
量预测框架只能预测第 
5 
列开始的后 
J-q 
个流量值。
 
其次在相关趋势预测和扰动预测中，均采用 
BP 
神经网络的预测算法。一共设
置 
3 
层，每层包含的节点数目为 
2,2,1
。相应的传输函数为两个双曲正切 
S 
形函数，
两个对数 
S 
形函数，一个 
purelin 
函数。用于训练的函数为自适应梯度下降函数
traingdx
，其学习率 
Ir 

0.01
，最大迭代次数为 epoches 

2000 ，目标训练误差设为 
0.01
。
 
  
当前列中若剩余的所有 
J-q 
的流量被预测了，则流量预测程序将会对下一列的
J-q 
个流量值进行预测。每个未知流量的预测过程都被重复 
5 
遍次以获得无偏差的
实验结果。实验在 
Matlab R2012b 
上运行，实验电脑相应的配置为 
Windows XP
，
内存为 
2.6GHz Pentium Dual-Core E5300
。
 
  
实验结果的性能有三种衡量方式：
 
①
  
平均绝对预测误差（
Mean absolute prediction error
，
MAE
）：
 
1
1
I
I
I n
MAE M AE
I
 
 

       
（
4.30
）
 4  
基于趋势预测模型的时间序列异常检测
 
75 
5
( , ) ( , )
1 1 
( , )
1
_
5
J
j I j I
I
cnt j q 
j I
tr pr tr
MAE
tr
  

 
 
      
（
4.31
）
 
其中 
I 
是预测算法经过的列数， 
I
MAE
是对第 
I 
列中所有 
J-q 
未知流量预测的
平均绝对误差，故 
I
MAE
表示每一列的平均绝对预测误差。
 
②
  
归一化均方根预测误差（
Normalised mean square prediction error
，
NMSE
）：
 
1
1
I
I
I n
NMSE NMSE
I
 
 

       
（
4.32
）
 
 
5
2
( , ) ( , )
1 1
1 1
_
5
J
I j I j I
cnt j q
NMSE tr pr tr
J q
  
 

 
    
（
4.33
）
 
其中 
I
NMSE
  
表示对列 
I 
上 
J-q 
个流浪值的预测产生的归一化均方根误差。
 
③
  
训练样本时间（
Training time
）：
 
MAE 
和 
NMSE 
都用于测量预测的精度偏差。
ANNs 
中最耗费时间的是对训练
数据的学习过程，往往需要大量的样本，多次的迭代，才能得到一个较好的优化
参数。因此样本的训练时间长短也用于衡量算法的性能。 
4.5.1  
参数估计
 
①
  
参数
1
 
和
2
 
的确定
 
在趋势提取过程中，我们需要确定参数
1
 
和
2
 
的值。根据公式（
4.18
），参数
1

所在的第二项是为了惩罚每列数据中方差大的点，且保存了较明显的结构特征，
1

越大，趋势越平滑。
2
 
所在的第三项保存了每列之间的相似度结构，
2
 
越大，趋
势中列之间的相似度越大。
 
通过计算不同参数下提取趋势的能量损失来权衡参数的值。这里能量损失可表
示为
1 /
tt tr

E E 
，其中
2
( , )
1 1
I J
tr j i
i j
E tr
 
 
 
  
且
2
( , )
1 1
I J
tt j i
i j
E tt
 
 
 
。由图 
4.7 
最终选择
1
 
0.5
和
2
 
0.05 
来均衡趋势提取中相关特征保持，周期特征保持和能量损失的情况。
 4  基
于趋势预测模型的时间序列异常检测 
76 
 
图 
4.7  
数据集
'DEC-PKT1'
中所提取的趋势的能量损失随
1
 
和
2
 
的变化。其中
1
 
, 
2
 
 

{0, 0.01, 0.05, 0.1, 0.5,1}
。
 
Fig.4.7 Energy loss of the extracted trend when 
1
 
  and 
2
 
  vary in trace 'DEC-PKT1'. 
1
 
, 
2
 
 

{0, 0.01, 0.05, 0.1, 0.5,1}
. 
 
②
  
训练样本数目参数 
q 
虽然本章提出的算法在预测 
k 
个值的时候需要
(k+q)n+q 
个原始流量值，然而这
些流量值并不直接作为 
ANNs 
模型的输入，而是经过处理生成的 
q 
个数据作为训
练样本直接输入。因此 
q 
被看做是是训练样本数目的参数。
 
元预测过程中，训练样本数目参数 
q 
影响着输出的精度。本章在数据集
‘
DEC-PKT1
’上验证了不同长度的训练样本数对预测结果的影响。如图 
4.8 
所示，
由 于 
  q<J 
， 
J=600 
， 因 此 实 验 设 置 
q 
的 范 围 为 
[60 
， 
480] 
， 即
 
q 

[0.1J, 0.2J, 0.3J, 0.4J, 0.5J, 0.6J, 0.8J] 
。
 
图 
4.8 
记录了在不同训练样本数目参数 
q 
下所提的方法预测性能。随着样本数
目的增加，
MAE 
和 
NMSE 
不断减小，表明算法的预测精度越高。由图 
4.8 
可知，
当 
q 
增加至 
0.4J=240 
时，本章算法的 
MAE 
值下降至 
0.04 
左右，而 
NMSE 
值减小
至 
0.025 
左右。因此后续实验中元预测时每次迭代的训练样本数 
q 
大小设置为 
0.4J
。
 4  
基于趋势预测模型的时间序列异常检测
 
77 
 
图 
4.8 
不同训练样本数目下本章算法的预测性能。（上）不同训练样本数目参数 
q 
下的 
MAE
值。（下）不同训练样本数目参数 
q 
下的 
NMSE 
值。
 
Fig.4.8 Prediction performances of the proposed prediction method under different training size. 
(Upper), MAE versus training size parameter q. (Below), NMSE versus training size parameter q. 
 
4.5.2  
预测结果的精确度分析
 
对于上述两个数据集进行预测，收集每列的
I
MAE 
和
I
NMSE 
值。其中数据集
‘
DEC-PKT1
’的结果如图 
4.9 
所示，序列
I
MAE 
和
I
NMSE 
的均值较小，且接近 
94%
的点位于 
 
c*
 
范围内，其中
c 

1.64
，对于
I
MAE 
序列，其均值和标准差分别为
 
0.040 和 
 
0.031
；而对于
I
NMSE 
序列，相应的均值和标准差分别为 
 
0.024
和
 
0.022
。表 
4.1 
记录了本章所提的算法和通用 
BP 
算法的对比结果。本章提出
的预测模型在平均绝对预测误差 
MAE 
和归一化均方预测误差 
NMSE 
两个衡量标
准上比通用的 
BP 
模型优秀，特别是在 
MAE 
中，效果提升了 
24.5%
。
 
 4  基
于趋势预测模型的时间序列异常检测 
78 
 
图 
4.9  
对数据集‘
DEC-PKT1
’的列进行预测，得到
I
MAE 
（上）序列和
I
NMSE 
（下）序列。
每一列记录 
1 
分钟内 
600 
个流量测量值。前 
4 
分钟的流量值已知，故从第 
5 
分钟开始进行预
测。
 
Fig.4.9 
I
MAE 
  (upper) and 
I
NMSE 
  (down) of the predicted columns on 
the trace  
’
DEC-PKT1
’
. Each column spans over 1 minute. Traffic measurements of the first four 
minutes are known, hence, the prediction process starts their work at the fifth column. 
 
表 
4.1  
通用 
BP 
神经网络的模型和本章提出的模型之间预测性能的比较
 
Table 4.1 Prediction performance of original BP-based prediction model versus the proposed model. 
  MAE  NMSE 
经典 
BP 
模型
  0.053  0.027 
本章的模型
  0.040  0.024 
 
对于 
Abilene 
数据集中的 
5 
条链路，图 
4.10 (a)
、
(b)
、
(c)
、
(d)
和
(e)
分别列举了
本章算法在预测时产生的
I
MAE 
和
I
NMSE 
序列。表 
4.2 
列举了 
5 
条链路的 
MAE 
和
NMSE 
值。由表 
4.2 
知，所提的模型在随机选择的 
5 
条链路上都具有较高的预测精
度，特别是在第 
1,3,5 
条链路上。由图 
4.10 
知，预测误差变化大的点通常比较集中，
例如第 
1,2,3,5 
条链路上第 
400 
天至第 
500 
天的预测误差变化较剧烈。进一步研究
得知，这段时间内存在重大的节假日。可能是节假日改变了用户的行为模式，例
如用户的上网时间，和使用的网络应用等，这直接导致了流量模式的变化，使其
更难被预测。
 
 4  
基于趋势预测模型的时间序列异常检测
 
79 
（
a
）
对 
Abilene 
中第 
1 
条链路进行预测得到
 
I
MAE 
（左）和
I
NMSE 
（右）序列
 
(a)
I
MAE 
  (left) and 
I
NMSE 
  (right) of the predicted columns in trace 1 from 'Abilene'.  
（
b
）
对 
Abilene 
中第 
2 
条链路进行预测得到
 
I
MAE 
（左）和
I
NMSE 
（右）序列
 
(b)
I
MAE 
  (left) and 
I
NMSE 
  (right) of the predicted columns in trace 2 from 'Abilene'.  
（
c
）
对 
Abilene 
中第 
3 
条链路进行预测得到
 
I
MAE 
（左）和
I
NMSE 
（右）序列
 
(c)
I
MAE 
  (left) and 
I
NMSE 
  (right) of the predicted columns in trace 3 from 'Abilene'.  
（
d
）
对 
Abilene 
中第 
4 
条链路进行预测得到
 
I
MAE 
（左）和
I
NMSE 
（右）序列
 
(d)
I
MAE 
  (left) and 
I
NMSE 
  (right) of the predicted columns in trace 4 from 'Abilene'.  4  基
于趋势预测模型的时间序列异常检测 
80 
（
e
）
对 
Abilene 
中第 
5 
条链路进行预测得到
 
I
MAE 
（左）和
I
NMSE 
（右）序列
 
(e)
I
MAE 
  (left) and 
I
NMSE 
  (right) of the predicted columns in trace 5 from 'Abilene'.  
图 
4.10  
对 
Abilene 
中 
5 
条链路进行预测。链路转化的矩阵中每一列表示一天。前 
n=4 
列流量
是已知的，故从第 
5 
列开始进行预测。任意被预测的列 
I
（
I>4
）中用于训练的样本数 
q = 120
。
 
Fig.4.10 Prediction perfomance of 5 traces in 'Abilene'. Each column represents one day. The first 
n 

4 
  columns are known, and the number of samples for training in column I(I>4) is q = 120. 
 
表 
4.2  
对 
Abilene 
的 
5 
条链路进行预测的 
MAE 
和 
NMSE 
值
 
Table 4.2 MAE and NMSE of 5 traces in ‘Abilene’ using the proposed prediction model. 
  Trace 1  Trace 2  Trace 3  Trace 4  Trace 5 
MAE  0.0070  0.026  0.011  0.052  0.0013 
NMSE  0.0028  0.0086  0.0036  0.013  3.9e
-04
 
 
4.5.3  
时间效率分析
 
所有的基于学习的预测模型，其时间消耗被分为两个部分：训练时间和预测时
间。基于 
ANNs 
的预测模型中，训练样本数远大于测试样本数，故 
ANNs 
中耗费
时间较多的是模型的建立过程。
 
图 
4.11 
记录了在不同训练时间下两种方法的性能。当 
MAE 

0.04
时，所提出
的模型耗费的时间小于 
BP 
算法耗费的时间。类似的，在 
NMSE 
中，当 
NMSE 

0.025
时，本章的预测模型需要的训练时间远小于 
BP 
算法。因此可以得出结论：与 
BP
算法相比，本章的预测模型能用更少的训练时间，产生更高的预测精度。
 4  
基于趋势预测模型的时间序列异常检测
 
81 
图 
4.11  
不同训练时间下所提出的预测算法和经典 
BP 
算法的预测性能对比。（上），不同训练
时间下的 
MAE 
值。（下）不同训练时间下的 
NMSE 
值。在较高的预测精度下（ 
MAE 

0.04 
或
NMSE 

0.025 
），所提出的模型的训练时间远小于经典 
BP 
算法需要的时间。
 
Fig.4.11 Prediction performances of the original BP-based prediction method and proposed method 
under different training time. (Upper), MAE versus training time. (Below), NMSE versus training 
time. At higher prediction accuracy ( 
MAE 

0.04 
  or  
NMSE 

0.025 
), the training time cost by 
the proposed method is far smaller than that by the original BP-based prediction method. 
 
4.5.4  
合成数据中基于预测的异常流量检测
 
  由于无法获得被标记的流量数据，本节首先利用合成数据对基于预测的异常流
量检测算法进行性能分析。与预测中使用的两种类型的数据集类似，本节生成了
两种类型的数据：与‘
DEC-PKT1
’对应的数据集 
S1
，时间长度为 
1 
小时，每分
钟收集 
600 
个数据点，共包含 
36000 
个数据；以及与 
Abilene 
相对应的数据集 
S2
，
时间长度为 
10 
周，一天收集 
288 
个数据点，共有 
20160 
个数据。
 
其中 
S1 
是由多个独立同分布的 
ON-OFF 
模型基于 
pareto 
分布生成的具有自相
似特征的流量序列。
ON-OFF 
模型对主机的行为状态做了定义：
ON 
阶段主机按照
一定的频率发送流量，
OFF 
阶段主机停止发送流量，进入睡眠阶段。其中 
ON 
阶
段和 
OFF 
阶段的持续时间分别满足各自的 
Pareto 
分布。相应的分布参数分别设置4  基
于趋势预测模型的时间序列异常检测 
82 
为 
ON 
阶段最小值是 
10ms
，α为 
1.1
；
OFF 
阶段的最小值是 
28ms
，α为 
1.2
。
ON
阶段流量发送的频率为 
0.001s
，其发送的流量值满足均匀分布 
U[64,1514]
。
 
而 
S2 
的生成过程与 
3.4 
节类似，采用正弦函数模拟网络流量的周期性特征，
采用标准的正态分布作为流量的白噪声，其中分布的幅值为标准网络流量的 
10%
。
3.4.1 
节定义的异常类型同样也适用于数据集 
S1 
和 
S2
。
 
与第三章中对异常的检测算法一样，通过预测值和实际流量值的误差进行判
断：如果某个误差落在边界外，则该位置的流量数据为异常数据，反之，若误差
落在边界内部，则为正常数据。此处边界采用 
2.1.1 
节中置信区间的方式定义，主
要包含误差序列的均值
,
标准差和显著性水平三个元素。显著性水平范围为
[1.0
，
4.5]
。
 
由于本章是基于预测的方式对流量进行检测，因此只采用同为预测类型的异常
检测算法作对比。和 
4.5.2 
节类似，本节采用的对比算法是基于 
BP 
的神经网络预
测的异常检测算法，并根据 
3.4.2 
节提出的第一对评价准则对所提的算法和经典 
BP
算法的性能进行对比。实验重复 
5 
次以获得无偏的检测结果。图 
4.12 
和图 
4.13 
分
别记录了两种算法在合成数据上的检测性能。越靠近图像左上方的曲线其对应的
算法性能越好。因此本章提出的异常检测算法优于 
BP 
算法。
 
 
0 0.05 0.1 0.15 0.2 0.25 0.3 0.35
0
0.2
0.4
0.6
0.8
False alarm probability on anomaly points (FAP_AP)
D
e
t
e
c
t
i
o
n 
p
r
o
b
a
b
i
l
i
t
y 
o
n 
a
n
o
m
a
l
y 
p
o
i
n
t
s
(
D
P
_
A
P
)
 
 
The proposed method
Original BP method
 
图 
4.12  
本章算法和经典 
BP 
算法在数据集 
S1 
上的检测性能（
FAR_AP  
和
  DR_AP
）。异
常类型为 
FIFD
，宽度系数 
ψ = 10
，幅度值可随机选择。
 
Fig.4.12 The performance comparision of the proposed method and classical BP method on S1 
(FAR_AP versus DR_AP). The type of anomaly is FIFD, the width parameter is ψ = 10, and the 
magnitude value is randomly choosed. 4  
基于趋势预测模型的时间序列异常检测
 
83 
0 0.05 0.1 0.15 0.2 0.25 0.3 0.35
0.2
0.4
0.6
0.8
1
False alarm probability on anomaly points (FAP_AP)
D
e
t
e
c
t
i
o
n 
p
r
o
b
a
b
i
l
i
t
y 
o
n 
a
n
o
m
a
l
y 
p
o
i
n
t
s
(
D
P
_
A
P
)
 
 
The proposed model
Original BP method
 
图
  4.13  
本章算法和经典 
BP 
算法在数据集 
S2 
上的检测性能（
FAP_AP  
和
  DP_AP
）。异常类
型为 
FIFD
，宽度系数为 
ψ = 10
，幅度值可随机选择。
 
Fig.4.13 The performance comparision of the proposed method and classical BP method on S2 
(FAP_AP versus DP_AP). The type of anomaly is FIFD,   the width parameter is ψ = 10, and the 
magnitude value is randomly choosed. 
 
4.5.5  
真实数据中基于预测的异常流量检测
 
本节在数据集‘
DEC-PKT1
’上验证了本方法在异常流量检测上的性能。由 
3.5
节知现实生活中很难找到被标记的网络流量数据集，通常将当前流行的异常检测
算法对流量的检测结果作为“真实地”异常数据。本节依然根据 
3.4.2 
节提出的第
一对评价准则对比所提的算法和 
BP 
算法。
 
本节采用 
PCA 
算法作为流行的异常检测算法，与 
3.4 
节中基于 
PCA 
的检测方
法一样，通过选择前 
k 
个具有最大特征值的特征向量对正常流量进行建模，并通
过误差对网络流量进行异常检测。
 
基于预测的方法进行异常检测的过程重复执行 
5 
次以获得无偏的检测结果。本
章提出的预测方法和 
BP 
预测方法进行异常检测的结果如图 
4.14 
所示。由图可以
发现相比于 
BP 
算法，本章所提出的方法能够检测出更多的 
PCA 
类型的异常点，
其检测精度约为 
BP 
算法的一倍。与此同时发现所提出的预测方法的误检率比经典
BP 
神经网络算法低，这说明与经典 
BP 
算法相比，本章提出的算法检测到的不属
于 
PCA 
类型的异常点数目更少。总体来说，本章的算法检测性能更优越。
 4  基
于趋势预测模型的时间序列异常检测 
84 
0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18
0
0.1
0.2
0.3
0.4
0.5
False alarm probability (on PCA detected anomalies)
D
e
t
e
c
t
i
o
n 
p
r
o
b
a
b
i
l
i
t
y 
(
o
n 
P
C
A 
d
e
t
e
c
t
e
d 
a
n
o
m
a
l
i
e
s
)
 
 
The proposed method
Original BP method
 
图 
4.14  
本章所提的预测算法和经典 
BP 
神经网络算法在异常检测性能上的对比。两种算法使
用的训练样本数为 
240
。
PCA 
中使用了前 
30 
个特征向量构建正常流量空间，保存了原始数据
80%
的信息。。
 
Fig.4.14 The anomaly detection performance of the proposed method versus original BP method. 
The size of training samples is 240 in two prediction methods. In PCA, we use the first 30 
eigenvectors to express the normal network traffic and keep 80% energy. 
 
4.6  
本章小结
 
本章根据用户（或网络）正常行为模式提出了基于趋势预测模型的异常检测算
法。该算法对比预测值和实际值的差异判断新数据是否异常。基于趋势的流量预
测算法将流量分为周期，相关趋势和扰动三个部分，并对每个部分别预测。与 
BP
神经网络模型相比，本章的预测模型具有更高的精度，且结果具有可解释性。基
于趋势预测的异常检测算法在大时间尺度和小时间尺度下都具有较高的检测效
果。
 
  
本章提出的模型认为网络流量的趋势具有周期性和短时相关性，其假设基础为
用户的网络行为模式的变化较为缓慢。因此本章的模型并不适用于网络流量变化
较强情境，例如节假日中对流量的预测和异常检测。由此未来研究的一个重要方
向是，如何在用户（或网络）正常行为模式发生变化的时候及时精确的对网络流
量进行预测并进行异常检测。由于引起行为模式变化的外因大多基于用户上网习
惯的变化，因此分析这类外因（如节假日，兴趣偏移等）并将其作为先验知识构
建正常网络流量模型，增强模型对外在因素的自适应能力，是一种可能的解决问
题方式。另外一个问题是如何设计神经网络的结构使其能够高效精确的进行预测
或检测，一种解决方案是利用深度学习（
Deep learning
）的思想通过多层有效的提
取网络流量时间序列的特征实现更高效精确的预测。5  
基于异常行为模式的时间序列异常检测
 
85 
 
5  
基于异常行为模式的时间序列异常检测
 
 
5.1  
引言
 
第三章和第四章分析用户的正常行为模式实现对时间序列的异常检测。现实应
用中，也可以对用户的异常行为模式进行分析，提取异常行为模式的特征，实现
对时间序列的异常检测。一个典型的应用就是推荐系统中的托攻击检测。
 
以广泛应用的协同过滤推荐系统为例。托攻击在 
CF 
推荐系统中通过构造虚假
用户对目标项目的评分使目标项目的整体特征发生变化，如提高或者降低项目的
整体评价，增加或者减少项目与特定项目的相似程度等。由于 
CF 
推荐系统基于用
户或者项目之间的相似度进行协同推荐，因此托攻击者通过注入异常评分使项目
的口碑或者被推荐的概率按照其意图发生改变。
 
对托攻击的检测，目标在于发现虚假的用户及其异常评分。由于虚假用户会通
过各种手段将自己伪装为正常用户，而正常用户也可能出现异常的评分举动，因
此从用户的角度分析其行为模式很难找到有效特征实现对托攻击的检测。
 
实际应用中，通常要求系统能及时有效地发现托攻击的异常评分，因此对托攻
击的检测方法应当具有实时性和较低的时间复杂度。由于在线系统通常以流的形
式存储不断更新、动态变化的评分时间序列，因此托攻击的检测方法要求最好能
一次读取产生结果。
 
在线异常检测中，不同的时间尺度下同一个异常检测算法对同一个时间的评分
进行检测，可能会产生不同的检测结果。这种检测结果的不一致性导致了系统推
荐的不稳定性，降低了用户的满意度。
 
针对上述问题，本章从项目的角度出发，分析用户的异常行为模式（主要是异
常评分模式）产生的异常评分在项目的评分时间序列（对特定的项目，将所有用
户对该项目的评分按照时间先后排序得到项目的评分时间序列）上的情境属性和
行为属性，并基于这类属性提取特征设计算法，以实时的区分正常评分数据和异
常评分数据。
 
此外本章基于不同时间尺度下检测结果的不一致性，分析了算法的稳定性特
征，设计了稳定性评价准则。实验表明，本章提出的异常检测算法不仅具有较低
的误检率，较高的检测精度，还具有较强的稳定性，且算法的时间复杂度低，能
实时生成异常检测结果。
 
 
5.2  
时间序列统计分布的不对称性研究
 
在概率统计理论中，偏度用于衡量数据的概率分布对于其均值的不对称程度。重庆大学博士学位论文 
86 
偏度可以为正值（
Positive
），负值（
Negative
）或者是为 
0
（
Undefined
）。在单峰分
布中，负偏度意味着均值左侧尾部的概率密度比右侧的更长。相反，正偏度表示
均值右侧尾部的概率密度比左侧的更长。
0 
值表示分布是关于均值是均衡的。
 
 
 
图 
5.1  
单峰分布中的偏度。
 
Fig.5.1 The skewness of the distribution of univariate data. 
 
设 
X 
为随机变量，
c 
为常数，
k 
为正整数，则变量

  

 
ｋ
Ｅ Ｘ－ｃ
称为 
X 
关于 
c 
点
的 
k 
阶矩。当 
c=0 
时，
k
Ｅ(X )
称为 
X 
的 
k 
阶矩。当
c=Ｅ(X)
，这时
 
( )

k
k
 
E 

X 

E X 

 
称为 
X 
的 
k 
阶中心矩。一阶中心距就是期望，一阶中心矩 
1
 
0
，二阶中心矩 
2

是
方差。三阶中心矩就是偏度
[66]
。
 
我们定义偏度系数（
Coefficients of skewness
）来衡量偏度，即
3/ 2
1 3 2
  
。随
机抽取样本 
n 
个样本数据，则样本偏度系数可表示为：
 
3
1
3
1 
3/ 23 2
2
1
1
( )
1
( )
1
n
i
i
n
i
i
x x
m
n
s
x x
n




 
 

 

 


     
（
5.1
） 
其中 
x 
是样本均值， 
s 
是样本标准差，
3
m 
是样本三阶中心矩。
 
除了用基于定义的偏度系数衡量偏度之外，还有多个偏度衡量方法。定义随机
变量 
X 
的均值为
1
 
，标准差为 
1/2
2
 
，众数为
mo
x 
，中位数为
me
x 
，四分位数分别为
1
Q 
，
2
Q 
，
3
Q 
，
4
Q 
。
 
为常用的偏度衡量方法有
[141]
：
 
①
  
皮尔逊众数偏度（
Pearson mode skewness
）。又称为第一偏度系数。
 5  
基于异常行为模式的时间序列异常检测
 
87 
1
1 
1/ 2
2
mo

x



 
        （5.2
） 
②
  
皮尔逊中位数偏度（
Pearson median skewness
）。又称为第二偏度系数。
 
1
1 
1/ 2
2
3( )
mo

x



 
        （5.3
）
 
③
  
基于分位数的偏度。又称为 
Yule  
系数。
 
1 3 2
1
3 1
Q Q2Q
Q Q

 


       （5.4
）
 
④
  Groeneveld & Meeden 
系数。与 
2
）类似，可用于替代偏度衡量。
 
1
1
me
me
x
E X x




  
 
       （5.5
） 
其中
|
…
|
表示绝对值。
 
⑤
  
基于距离的偏度。由于偏度无法判断分布是否对称，可以从距离的角度进
行衡量。假设随机变量 
X 
取值于 
d 
维欧式空间，
X 
存在期望值，且 
X’
独立分布于
X,
  
. 表示欧几里德范式。进而我们得到非对称性的衡量为： 
'
( ) 1 Pr( 0) 1
'
E X X
d Skew X if x
E X X

   

    （5.6
） 
其中当 
X=0 
的概率 
Pr(x=0)=1 
时，
d Skew(X)=0
。基于距离的偏度变化范围为
[0,1],
当为 
0 
时，
X 
为对角型对称，当为 
1 
时，
X 
为一个非零常数。
 
⑥
  
鲁棒性偏度。
Medcouple 
是一个尺度不变的鲁棒的偏度衡量方式。对随机
变量 
X 
的任意 
n 
个取样，其 
Medcouple 
值为：
 
( ) ( )
( , )
i me me j
i j
i j
x x x x
h x x
x x
  


     （5.7
）
 
其中
i me j
x 

x 

x 
。
 
 
5.3  
基于异常行为模式的异常评分时间序列检测
 
5.3.1  
问题的定义和解决方案的分析
 
5.1 
节的三类问题可以被总结为托攻击异常评分特征提取、异常评分检验以及
算法的评价问题。具体的问题定义和解决方法的分析如下：
 
①
  
分析托攻击构造的虚假用户的异常行为模式。
 
直接从用户的角度进行虚假用户检测具有较大的难度，且检测效果并不理想。重庆大学博士学位论文 
88 
而从项目的角度分析用户的异常行为模式，总结异常评分在项目的评分时间序列
中的情境属性和行为属性，提取异常评分的特征，有利于异常评分的检测。
 
根据 
1.3 
节对于托攻击异常类型的介绍，只有当目标项目的评分分布发生较大
变化的时候，项目的整体评价才会发生变化，进而被推荐的概率也会发生变化。
为了达到这一目标，托攻击要求大量的虚假用户在一个较短的时间内对目标项目
注入（极高或者极低的）评分。因此从项目的角度分析用户异常行为模式产生的
异常评分具有明显的时间集中性和统计特性。
 
②
  
提取特征并设计有效的异常检测算法。
 
根据托攻击异常评分的情境属性和行为属性，提出基于每个评分对项目当前分
布的贡献作为度量标准，实现评分时间序列的聚类。根据相邻评分对当前项目的
评分分布的贡献是否一致，对时间序列进行分割。贡献一致的相邻评分被分在一
个时间区间内，而贡献不一致的相邻评分被分在不同的时间区间内。最终项目的
评分时间序列被动态地分割为大小不等的数个时间区间。由于异常评分的注入具
有时间上的集中性，使用上述基于动态分割时间序列的聚类算法可以将异常评分
集中在同一个类。对聚类的异常检测就是对类的统计特征进行假设检验，判断其
是否为异常类的过程。这种算法适用于任何托攻击类型，且时间复杂度低，可以
用于在线检测。
 
③
  
基于时间序列的算法的稳定性的分析和评价标准制定。
 
当前文献对于检测算法的评价主要集中在衡量算法的有效性，使用的评价标准
有精确度，召回率。
F1 measure 
等。另外一个重要的适用于在线异常检测的评价标
准为算法的稳定性
[142, 143]
。算法的稳定性主要衡量在线检测中同一个数据点在不同
时间尺度下使用同一个算法产生的检测结果的一致性程度。不同的时间尺度，意
味着用于异常检测的时间序列长度不同。以包含该数据点的当前时刻和后续有新
数据到来的时刻为例，后续时刻对该异常点的检测受到新数据的影响可能产生与
初始异常检测完全不一样的结果。这种结果的不一致性导致系统无法为用户提供
可靠的决策，降低用户的满意度。基于不同时刻异常检测算法对相同数据的检测
结果，本章提出基于结果偏移程度的稳定性评价标准。
 
5.3.2  
异常评分检测的基本定义
 
定义 
1.  
项目概貌（
Item profile
）项目 
k 
的概貌
'
k
r
，是指用户集 
U 
对项目 
k 
的
所有评分集合。将
'
k
r
中的评分按照时间顺序排列得到项目的评分时间序列
k
r
，如公
式（
5.8
）所示。
j
i
u k
r
表示 
k
r
的第 
i 
个评分来自于用户 
u
j
。
 
a b j m
1 2 i n
k u k u k u k u k a b j m
r {r

,r ,..r .,r },i 

1,2,3,...,n;u ,u ,u ,u 

U
   
（
5.8
）
 5  
基于异常行为模式的时间序列异常检测
 
89 
定义 
2.  
评分矩阵（
Rating matrix
）所有项目 
P 
的概貌形成了评分矩阵 
R
，大小
为 
U ×P
。 
uk
r 

R
表示 
R 
中的每个单元是用户 
u 
对项目 
k 
的评分。因此 
R 
的每一
列表示项目的概貌，每一行表示用户的概貌。令 
D
R
为检测空间，其将 
R 
中的评分
分为正常和异常两组。
 
定义 
3.  
时间矩阵（
Time matrix
）与定义 
2 
类似，我们将所有用户 
U 
对所有项
目 
P 
的评分时间构成时间矩阵，大小为 
U ×P
。其中每一列表示对项目评分的时间
集合，每一行表示用户对评分时间集合。
 
定义 
4.  
检查点（
Checkpoint
）在线系统中，检查点是指异常检测算法被激活执
行检测的时间戳。通常执行异常算法的时间是有规律的。因此在不同的时间点，
系统能收集到不同尺度大小的子评分矩阵。假设一个连续的检测点序列 
C = 
{c
1
,c
2
,c
3
,c
4
,c
5
}
，其中 
c
1
< c
2
< c
3
< c
4
< c
5
。相应的，其收集到的子评分矩阵 
R
sub
之间
的关系为
1 23 45
c cc cc
sub sub sub sub sub
R 

R 

R 

R 

R
。
 
定义 
5.  
生命周期（
Life cycle
，
LC
）在每个子评分矩阵
i
c
sub
R 
中，项目的生命周
期定义为从开始的评分时间 
S 
到当前检查点 
c
i
之前最后一个评分时间 
E
。在后续
的检查点中，除非有新的评分到来，否则项目的生命周期不会发生改变。
 
定义 
6.  
时间区间（
Time interval
）生命周期的一段时间称之为项目的一个时间
区间。
 
定义 
7.  
检测模型（
Detection model
）本质上对异常的检测可看做是分类模型
f: R 

{0,1} ，其中 0 
表示正常类，而 
1 
表示异常类。用
i
c
sub
D
表示在检查点 
c
i
处收
集子评分矩阵
i
c
sub
R
，则
{( , ) | , , {0,1}}
i
c i i
sub uk i uk
D 

r cid i 

c r 

R cid 

。通常检测系统
DS 
构建了检测模型为
,
( )
c
i
sub
i
uk
DS D
cid 

f r 
，其中 
cid 
是由系统
DS 
生成的检测结果。
  
5.3.3  
基于项目概貌的托攻击异常评分分析
 
从项目的角度对用户的异常行为分析可以发现托攻击中虚假用户的异常评分
特征如下：
 
①
  
虚假用户倾向于向项目注入与其当前评分分布大不相同的评分。通常注入
的评分为 
r
max
/r
min
。
 
假设项目本身的品质满足均匀分布
[144]
，则用户对项目的正常评分分布应当是
平稳的。一旦项目的评分分布出现较大的变化，表明项目的评分时间序列中被注
入了异常评分。尽管托攻击具有多种攻击类型，然而任意有效攻击的目标在于按
照攻击者的心愿对项目的统计特征进行改变，进而改变其被推荐的概率。例如，重庆大学博士学位论文 
90 
为了提高项目被推荐的概率，托攻击向该项目注入大量的高评分，相应的该项目
评分序列的均值和众数等统计特征值也增加了。因此通过项目的评分分布进行检
测，可以及时发现与当前评分分布大不相同的异常评分。
 
②
  
异常评分的数目必须足够大以使项目的评分分布按照攻击者的意图变化。
 
  
通常需要向目标项目注入大量的异常评分，使目标项目的评分分布按照攻
击者的意图发生变化。如果目标项目的评分时间序列较短，相应的较少的异常评
分数目可以改变其分布，如果目标项目的评分时间序列较长，则需要较多的异常
评分数目改变其分布。
 
③
  
为最小化攻击的开销，通常托攻击的持续时间较短且较为集中。
 
托攻击发起者需要在项目被成功推荐产生的效益和构建虚假用户概貌需要的
经济和时间上的开销上做出平衡，即以最小的经济和时间上的开销换取最大的效
益。通常的解决方法是在尽可能短的时间内集中注入异常评分。因此在项目的评
分时间序列中，异常评分之间的时间差距比较小，甚至是邻居。
 
上述异常评分的三个属性中，前两个属于评分的行为属性，最后一个属于评
分的情境属性。基于这类属性可以有效的区分正常用户评分和托攻击虚假用户的
评分。
 
通过对托攻击用户评分的分析，提取具有普适性的异常评分的特征，为虚假
用户的判断提供准确的依据。
 
5.3.4  
基于项目概貌的托攻击异常评分特征提取
 
由 
5.3.3 
节对于托攻击异常评分的分析知，异常评分的情境属性和行为属性能
够改变目标项目的评分时间序列的总体特征。因此选择评分对当前时刻项目的评
分时间序列分布的贡献作为特征，即可区分正常评分和异常评分。
 
由 
5.2 
节知，偏度用于衡量数据整体分布相对于均值的不对称性，因此偏度可
表示项目评分时间序列的统计分布。大量的异常评分会改变评分序列的不对称方
向，即偏度的值会随着异常评分的注入而发生变化。由此可用其度量评分对当前
分布的贡献。计算过程为：计算各项目的评分时间序列中每个时刻评分分布的偏
度，评分对当前分布的贡献可表示为偏度的变化（或一阶差分）。
 
对项目 
k
，在检查点 
c
i
处的评分序列为 
r
k
，序列中的每个评分都有相应的偏度
值，进而得到偏度序列为：
 
k k k
3 3 3 3 3
{ (1), (2),..., (i),..., (n)}
k k
γ 

γ γ γ γ
     
（
5.8
）
 
其中
k
3
γ(i)
表示第 
i 
个评分偏度，由公式（
5.1
）可得，
 
k 3 3/ 2
3 [1... ]
( ) ( ) / ( )
i k ik ik
γ i 

E r 

Er Dr
     
（
5.9
）
 5  
基于异常行为模式的时间序列异常检测
 
91 
其中
ik
Er 
是从第 
1 
个到第 
k 
个评分序列的期望值，而
ik
Dr 是从第 1 
个到第 
k 
个
评分序列的方差
[145]
。
 
每个评分对评分整体分布的贡献可以由偏度的一阶差分获得，即
 
3 3 3 3
( 1) ( 1) / ( 1) ( 1) ( )
k k k k

γ i 
  
γ i 
 
i 
 
γ i 
 
γ i
   
（
5.10
）
 
其中
3
( 1)
k

γ i 
 
表示第 
i+1 
个评分对项目当前评分序列统计分布的贡献，也是第
i+1 
个评分的特征。
 
5.3.5  
基于时间区间动态分割和假设检验的异常检测框架（
SDF
）
 
通过偏度的变化对相邻评分进行聚类，并利用假设检验的方法对类是否正常做
出判断。上述过程构成了一个新颖的异常评分检测框架，如图 
5.2 
所示。整个框架
分为两个部分：时间区间分割和异常区间检测。前者包括对评分分布变化的表示
和对评分序列的动态分割过程。后者用于包含异常评分的区间。
 
                                                                                
 
图 
5.2  
基于时间区间动态分割和假设检验的检测框架（
SDF
）。
 
Fig.5.2 Dynamic time interval segmentation and hypothesis test detection-based framework (SDF). 
 
①
  
对时间序列的动态分割。
 
  
通过分析相邻评分对项目当时整体评分分布的贡献类型对评分聚类，如果相邻
评分对分布的贡献类型是相同的则将其聚为一类，反之则聚在不同类。一个判断
贡献类型是否相同的有效方式是乘积。例如，若
k
3

γ(i)
是第 
i 
个评分对整体分布的
贡献， 
3
( 1)
k

γ i 

是第 
i+1 
个评分对整体分布的贡献。二者的乘积有三种结果：
 
k k
3 3
0;
( , 1) ( ) * ( 1) 0;
0.
D i i γ i γ i


     





      
（
5.11
）
 
当 
D(i, i+1)>0 
时，第 
i 
和 
i+1 
个评分对项目评分的分布的贡献是同一类型，即
它们都让评分的分布向左或者右倾斜。因此第 
i 
和 
i+1 
个评分属于同一类，应当被
划分为同一个时间区间内。对于 
D(i,  i+1)=0 
的情况，为了处理方便，也认为二者重庆大学博士学位论文 
92 
属于同一类，在同一区间内。
 
当 
D(i, i+1)<0 
时，第 
i 
和 
i+1 
个评分对项目评分的分布的贡献并不属于同一类
型，即它们让评分的分布向相反的方向倾斜。因此第 
i 
和 
i+1 
个评分不属于同一类，
应当被划分在不同的时间区间内。
 
这种分割的方式事实上将连续的意图相同的异常评分划分在相同的时间区间
内。其划分的时间区间大小是不定的，由评分的分布的变化决定的。因此我们认
为这种分割算法称之为基于偏度变化的动态时间区间分割算法，对于每个项目，
相应的分割算法可见表 
5.1 
 
表 
5.1  
对每个项目的动态时间区间分割算法
 
Table 5.1 Dynamic time interval segmentation algorithm for each item 
输入：检查点 
c 
处收集的项目 
k 
的按时间排序评分序列 
r
k
；
 
输出
:  
分割了的时间区间集合 
g
k
。
 
过程：
 
1:  
获取序列 
r
k
中每个项目的编号，以及长度 
n
。
 
2:  For i=1,2,3,...,n 
3: 
根据公式（
5.12
）和（
5.13
）迭代计算第 
i 
个评分所在时刻对应评分序列的均值和标
准差
 
 
j
1
i
u k
x (( 1) * x r ) /
i i
k k
i i

  
. 
（
5.12
）
 
j
i i-1 i
k k u k
(( ) ^ 2 * ( 1) (r ) ^ 2) /
i
k
δ 

δ i 
  
x i
. 
（
5.13
）
 
 
4:  
根据公式（
5.14
）计算第 
i 
个评分的偏度的变化作为贡献值
k
3

γ(i)
，
 
  
集合
k k k
3 3 3
{

γ(1),

γ(2),...,

γ(i)}
收集了直到编号 
i 
的所有评分的贡献。
 
5: 
如果 
i=1
，则第一个评分及其编号 
1 
被分配到组
'
g
i
k
，
  
 
'
g =1
i
k
，
i=i+1
。
 
6:  
如果
k
3

γ(i)=0 
，则第 
i 
个评分及其编号 
i 
被分配到组
'
g
i
k
。
 
7:  
否则
k
3

γ(i) 

0 
，根据公式（
5.14
）计算 
J  
 
 
k k
3 3
J 
 
γ(i 

1)*

γ(i)
. 
(5.14) 
8:  
如果 
J>=0
，第 
i 
个评分及其编号 
i 
被分配到包含第（
i-1
）个评分的组中。
 
9: 
否则 
J<0
，
' '
g g 1
i i
k k
 
，则第 
i 
个项目及其编号被分配到新的组
'
g
i
k
。
 
10:  end of for i. 5  
基于异常行为模式的时间序列异常检测
 
93 
②
  
基于假设检验的异常项目检测
 
分割程序之后，项目 
k 
的评分序列被分为 
n 
个组
1 2 '
{ , ,..., ,..., }
i n
k k k k k
g 

g g g g
，其
中
i'
k
g
表示第 
i’
个时间区间组，其均值为 
'
x
ki
，评分数目为
'
n
i
g
。根据中心极限定理
[146]
，项目 
k 
整个生命周期内的评分分布满足正态分布，其样本均值和标准差分别
为 
x
k
和

k
。利用统计假设的方式对上述各组做异常检测。通过检验各组（子区间，
或类）评分序列的统计特征与整个生命周期的评分序列的统计特征是否一致来判
断各组是否异常。因此定义两类假设：
 
H
0
: 
'
x
ki 

x
k
;  H
1
: 
'
x
ki 

x
k
. 
接受 
H
0
或者拒绝 
H
0
的临界区由公式（
5.15
）决定，其显著性水平

使用标准
正态分布的双边检测。
 
ki' k
i'
g 1- / 2
|x -x |
{ n u }
k
δ


     
（
5.15
）
 
其中显著性水平

是错误拒绝空假设概率的阈值，通常比较小，用于帮助用户
决定是否拒绝空假设。在实验中我们将选择最合适的

值。
1
 
是置信度水平，用
于衡量判断结果的可靠性。
 
如果公式（
5.15
）为真，则拒绝假设 
H
0
，表明用于检验的区间包含异常评分；
若公式（
5.15
）为假，则接收假设 
H
0
，表明相应区间的评分序列是正常的，其统
计特征与整个生命周期的评分序列的统计特征是一致的。
 
假设检验确定了被攻击的项目和异常评分所在的时间区间。基于此，系统可以
进一步检测给出异常评分的用户是否为虚假用户，或者修改相应用户的可信度和
项目的信誉值，以提供更可靠的推荐结果。
 
5.3.6  
异常检测算法的稳定性分析以及评价准则
 
与推荐系统的稳定性相对应，定义异常检测算法的稳定性为不同检查点下，收
集到的不同时间尺度的评分矩阵中，使用该异常检测算法对同一位置的评分的检
测结果是否一致。稳定性衡量了检测算法在不同尺度下对子评分矩阵检测结果的
一致性程度。对于一个具有强鲁棒性的检测算法，后续检查点下的检测结果与前
期检查点的检测结果相比不应具有太大的变化。为更好地了解稳定性，此处列举
一个简单的例子来说明。
 
我们收集了两个检查点（
c
1
和 
c
2
，其 
c
2
>c
1
）下对同一个项目 
i 
的评分序列，如
图 
5.3
（
a
）所示。随机选择两个时间戳 
t2 
和 
t3 
作为检查点，其中检查点 
c
1
位于时重庆大学博士学位论文 
94 
间戳 
t3
，检查点 
c
2
位于时间戳 
t2
。项目 
i 
的生命周期的起始时间为 
t1
。因此第一
个时间尺度（蓝色空心圆点）是时间区间
[t1
，
t3]
，检查点 
c
1
收集了该区间上的评
分序列；而第二个时间尺度（红色实心圆点）是时间区间
[t1
，
t2]
，检查点 
c
2
收集
了该区间上的评分序列。显然第二个时间尺度的序列完全包含第一个时间尺度的
序列。
 
采用基于 
X-bar 
的检测算法
[61]
对两个检查点下的时间序列分别进行检测。结果
如图 
5.3
（
b
）所示，其中 
0 
表示评分正常，
1 
表示评分异常。很明显，第 
11,13,19,22,23
个评分在不同尺度下的检查结果是不一致的。
 
这种不一致性表明了检测算法的不稳定性，其降低了用户对推荐系统的满意程
度，并会误导系统的进一步决策，例如更新用户可信度等。因此算法的稳定性具
有重视的价值。
 
 
 
 
图 
5.3
（
a
）两个时间尺度下项目 
i 
的评分序列；（
b
）基于 
X-bar 
算法对两个评分序列进行异常
检测的结果。
 
Fig.5.3 (a) Item i’s rating series of two time scales; (b) Detection in two time scales with x-bar-based 
method. 5  
基于异常行为模式的时间序列异常检测
 
95 
上述例子分析可知，一共有两种不一致的情况：一种情况是评分 
r
uk
在前期检
查点 
c
i
处结果为 
0
，为正常评分，在后续检查点 
c
j
处结果为 
1
，为异常评分；另一
种情况是评分 
r
uk
在前期检查点 
c
i
处结果为 
1
，为异常评分，在后续检查点 
c
j
,
处结
果为 
0
，为正常评分。第一种情况经常发生在项目生命周期的早期阶段，由于项目
的评分数目较少，其提供的信息不足导致算法对个评分的判断结果出现偏差。我
们认为这种情况是正常的。针对后一种情况，我们定义了稳定性的评价准则。通
过计算不同检查点下算法对同一位置评分的检测结果的偏移来衡量稳定性：
 
Δ
i j
i
c c
uk
r 

cid 

cid
       
（
5.16
）
 
其中评分 
r
uk
的检测结果在 
c
i
处为
i
c
cid ，在 c
j
处为
j
c
cid 。检测结果的偏移通过
差的绝对值来表示，并记录为 
Δ
i
uk
r 
。
 
基于公式（
5.16
）定义稳定性的衡量方式为：平均绝对偏移（
Mean absolute shift
，
MAS
）和均方根偏移（
Root mean squared shift
，
RMSS
）。相应的公式如下所示：
 
(1 / ) Δ
i
c
i
sub
c i
sub uk
i
r R
uk
MAS D r

 
     
（
5.17
）
 
2
(1 / ) (Δ )
i
ic
i
uk 
sub
c i
sub uk
r R
RMSS D r

 
     
（
5.18
）
 
异常检测算法越不稳定，得到的结果不一致性越高，相应的平均偏移 
MAS 
和
均方根偏移 
RMSS 
值越大。
 
5.3.7  
基于项目概貌的托攻击分类
 
由 
1.3 
节知，由于用户的偏好和评分行为是不断变化的，基于用户概貌可将托
攻击分为许多类，最终导致无论正常还是虚假用户的概貌都具有多样性。本章从
项目概貌的角度对托攻击的异常类型重新进行分类，试图以最小的分类数目包含
各种异常类型（仅考虑推攻击，因为核攻击的构成策略与推攻击是一样的，对于
推攻击的检测很容易扩展到对核攻击的检测中）：
 
①
  
最大值注入（
Maximum injection
，
MI
）。所有的攻击行为都是向目标项目
注入最大评分。表 
1.1 
的所有攻击类型都可以被归为这一类。
 
②
  
目标偏移（
Target shifting
，
TS
）。用于对目标项目攻击的评分中，一部分
进行偏移，如推攻击中使用 
r
max
−
1 
的评分，而核攻击中采用 
r
min
+1 
的评分。如果
偏移部分所占比例为 
0
，则 
TS 
转变为 
MI
。目标偏移包含了当前基于偏移的评分策
略，如 
Ao P
。
 重庆大学博士学位论文 
96 
③
  
目标噪声（
Target noise
，
TN
）用于对目标项目攻击的评分中，一部分评分
是随机生成的噪声。如果噪声评分所占比例为 
0
，则 
TN 
可被看做是 
MI
，它包含
了模糊攻击。
 
由上述分类可知，基于项目概貌的托攻击类型简单且具有普适性，便于后续
的实验。本章后续的实验对这三类异常进行仿真来验证算法的普适性，无需考虑
1.3 
节的具体的异常类型。
 
 
5.4  
基于真实数据集的实验评估和分析
 
个性化推荐领域中，常用的有 
Movielens
、
Each Movie
、
Book Crossing
、
Jester Joke
、
Netflix 
和 
Amazon 
等数据集，这类数据集的格式大多为用户对项目（电影，书，
笑话，商品等）进行评分。本章选择了最广泛使用的 
Movielens 
数据集
[147]
进行实
验，其中 
Movielens 
数据集含有 
1682 
个项目，
942 
个用户以及 
100000 
个评分。离
散评分的取值范围为
[1
，
5]
。对于每个项目，将其评分按照时间排序，得到项目的
评分时间序列。根据 
5.3.7 
节的三种托攻击类型，分别生成三种类型的攻击注入到
评分序列中用于实验。与
[61]
中对攻击的分类相对应，本章考虑对评分均值低的项
目进行推攻击（根据 
5.3.7 
节对于攻击策略的描述，很容易将当前实验转换为对评
分均值高的项目进行核攻击的检测）。
 
由
[61]
知，根据项目的评分数目，可以将项目分成高密度评分项目类，中密度评
分项目类和低密度评分项目类。因为高密度评分项目类的数量太少，不足以生成
可靠的实验结果，故将高密度评分的项目类并入到中等密度的项目类中，得到两
种项目类：第一类项目中的评分数目为 
40-80
，而第二类项目中的评分数目为 
80
以上。
 
通过衡量攻击评分的数目占项目原始评分数目的比例来衡量攻击的大小比例
（
Attack size ratio
），实验中攻击的大小比例范围为
[10%
，
100%]
，即上述两组的项
目中，至少有 
4 
个攻击评分。
 
为了分析算法的在线检测性能，实验仿真了在线检测的过程：在不同的时间戳
下设置了检查点，收集每个检查点处的项目评分序列，并对其进行检测。因此后
续检查点的评分序列总是包含前期检查点的评分序列，且各个检查点处项目评分
的均值，标准差等可能会变化。
 
本章基于算法的有效性，鲁棒性和及时性对算法的性能进行检测：
 
①
  
有效性。常用的评价准则是检测的精确度（
Detection rate
，
DR
）和误检率
（
False alarm rate
，
FAR
）。其中检测精度是指被检测到的异常评分数占实际异常评
分的总数的比例。这里当异常评分所在的时间区间被认为是异常的时候，就将该
评分视作异常。误检率是指正常评分所在的区间被错认为是异常占正常评分区间5  
基于异常行为模式的时间序列异常检测
 
97 
总数的比例。
 
②
  
鲁棒性。这里鲁棒性更多的是指检测算法在不同时间尺度（不同检查点）
下对同一位置评分的检查结果的稳定性。根据 
5.3.6 
节对稳定性的评价公式（
5.17
）
和（
5.18
）知，需要对任意两个检查点的结果进行比较以计算结果的平均偏移程度。
实际应用中为计算方便，只考虑相邻检查点的检查结果的稳定性，由此可得稳定
性衡量公式如下：
 
i (i 1)
( 1)
c c
,
(1 / ( 1)) |cid -cid |
i i
c C c C
MAS C


 
  
    
（
5.19
）
 
( 1)
2
, ( 1)
(1 / (| |-1)) ( )
i i
c c
ci C c i C
RMSS C cid cid

  
 
    
（
5.20
）
 
其中 
C 
表示所有检查点的集合。
 
③
  
及时性。由于 
SDF 
考虑了在线情境下对异常的检测，因此有必要考虑算法
的时间复杂度。
 
5.4 
节主要分为 
6 
个部分，其中 
5.4.1 
讨论了 
SDF 
算法中参数的确定；
5.4.2 
节
分析了 
SDF 
的检测结果。
5.4.3,5.4.4,5.4.5 
节分别从有效性，鲁棒性和及时性的角
度对算法检查结果进行了分析对比。此外，在 
5.4.6 
节我们对所提出的稳定性准则
的鲁棒性进行了检测。
 
5.4.1 SDF 
中相关参数的确定
 
①
  
假设检验中的显著性水平的确认
 
显著性水平是指空假设成立的情况下，检验统计量的值落在某个极端区域的概
率值。在公式（
5.15
）中，显著性水平值越小，则异常检测的结果越可靠。在此，
我们列举了 
6 
个备选显著性水平值以及相应的边界，并给出了每个显著性水平值
下，
SDF 
在三种攻击类型下的平均检测精确度和误检率之间的 
ROC 
曲线，如图 
5.4
所示。由图可知，检测精度在不同显著性水平下的变化并不太明显，而误检率的
变化比较大。综合两种评价标准，选择 
0.03 
作为本章实验的显著性水平值。
 
 
表 
5.2  
显著性水平

以及相应的边界 
(1 /2)
u

。
 
Table 5.2 Significance level value 

  and related boundary value  
(1 /2)
u

 

 
0.05  0.04  0.03  0.02  0.01  0.005 
(1 / 2)
u

  1.96  2.05  2.17  2.33  2.57  2.81 重庆大学博士学位论文 
98 
 
图 
5.4  
不同攻击类型下两个项目组的平均检测精度和误检率的 
ROC 
曲线。其中攻击类型有
MI
（上），
TS
（中），
TN
（下）。攻击大小为 
80%
。
 
Fig.5.4 ROC curves for MI (upper), TS (middle) and TN (lower), with six significance levels for 
both groups
。
Attack size is 80%. 
 
②
  
确定样本均值的边界
 
在线环境下，通常项目已有的评分不足以计算无偏的采样均值，或者评分序列
已经被攻击评分所污染以至于样本均值的计算出现偏移或者失效。例如为
Movielens 
中均分小于 
3 
的项目注入 
100%
大小的攻击评分，使其均分最终大于 
3
，
如图 
5.5 
所示，这种采样均值与真实均值之间有巨大的差距。
 
为了减弱这种差距，我们为分割的每个样本均值设置了一个额外的边界。首先
我们将各区间均值 
'
x
ki
与 
r（此处 
r 

3
，原因是 
Movielens 
数据集中只有 
1 
到 
5 
的 
5
个离散评分。如果 r
 

2 ，低评分区间太小，只有 1 
和 
2
，而高评分区间太大，有
3,4 
和 
5
；如果 r
 

4 ，则低评分区间大于高评分区间，因此 
r 

3 
是高低评分区间之
间的均衡。）作对比。如果高于一半的区间均值 
'
x
ki
大于 
r ，则限定样本均值 
x
k
不
得小于 
r 。否则如果高于一半的区间均值 
'
x
ki
小于 
r ，则限定样本均值 
x
k
不得大于 
r 。
图 
5.6 
统计了图 
5.5 
中所有项目受攻击后区间均值 
'
x
ki
大于 
r 和小于 
r 的数目。由图
5.5 
可知，尽管大多样本均值大于 
3
，然而部分项目中，仅有小于一半的区间均值 
'
x
ki
是大于 
r 的，因此将这类项目的采样均值边界设定为小于 3
。这种方式可以有效的5  
基于异常行为模式的时间序列异常检测
 
99 
降低样本均值 
x
k
和项目信誉之间的差距。
 
 
 
图 
5.5  
经过 
100%
攻击比例的推攻击后的项目的样本均值。
 
Fig.5.5 Sample average rating values of items after 100% push attack. 
 
 
图 
5.6  
图 
5.5 
中每个项目的区间均值大于 
r 
和小于 
r 
的数目对比。攻击大小比例为 
100%
，
r 
=3
。
 
Fig. 5.6 For items in Fig.5.5, numbers of interval average rating values larger than  
r 
  versus smaller 
than  
r 
, 100% push attacks,  
r 
=3. 
 
③
  SDF 
能够处理的攻击大小范围
 
图 
5.7 
所示为 
SDF 
在攻击大小范围为
[10%
，
100%]
，至少包含 
20 
个评分的项
目上的检测结果。随着攻击大小的增加，检测精度始终大于 
90%
，而误检率则不
断地增长。因此 
SDF 
在对上述攻击范围的评分序列进行检测时，检测效果较好的
范围是
[10%
，
80%]
，其中检测精度大于 
90%
，而误检率则小于 
4.2%
。
 重庆大学博士学位论文 
100 
 
图 
5.7  
不同攻击大小比例下检测精度（左）和误检率（右）。
 
Fig. 5.7 DR(left) and FAR(right) in different attack size ratios 
 
5.4.2 SDF 
的检测结果分析
 
图 
5.8 
显示了 
SDF 
对两组项目中三种类型的攻击的检测精度和误检率情况，攻
击比例范围为
[10%
，
100%]
。在图 
5.8
（
a
）中，随着攻击大小比例的不断增加，
MI 
的检测精度缓慢的增加，且保持在较高的水平。这是因为 
MI 
比较容易被检测
到。对于 
TS 
攻击类型，随着攻击不断地增多，
TS 
的检测精度不断下降，这是因
为 
TS 
类型评分中包含了非最大值的评分，很容易将自己伪装成正常的评分，易混
淆检测。至于 
TN 
类型的检测，它在所有范围的攻击比例中保持着稳定的且相对较
低的检测精度。可以将对 
TN 
类型的异常检测分为两个部分：对随机选择的噪声（评
分）的检测和 
MI 
类型攻击的检测。其中由于噪声是随机选择的评分，且所占比例
基本不变，因此很难对其做出正确的判断，而 
MI 
类型的检测精度则比较高。综合
起来，
TN 
的检测精度维持在低于 
MI 
检测精度的水平。同样的趋势在图 
5.8
（
b
）
中也可以发现。然而（
b
）图中对所有类型的攻击的检测精度明显大于（
a
）图，
这与期望相符合：更多的真实评分会使异常检测的结果更精确。
 
在图 
5.8
（
c
）图中，随着攻击大小比例的不断增长，
TS 
和 
MI 
攻击类型的误检
率不断地增长。然而 
TN 
类型的误检率基本维持不变，其原因与（
a
）图类似：
TN
中的噪声的比例基本保持不变。图 
5.8
（
d
）中展示了与（
c
）图类似的特征。除了
MI 
攻击类型，（
d
）图中的误检率和（
c
）图的误检率几乎一样，这可能是由于 
TS
和 
TN 
攻击类型中包含更多的易被混淆的评分。
 
总体来说对三种类型的攻击，
SDF 
对其的检测效果分别为
MI TN TS
DR 

DR 

DR
，
和
TN MI TS
FAR 

FAR 

FAR
。
 
这与事实相符合，即 
TS 
类型的异常评分最难被检测到，故其检测精度最低，
误检率最高。
MI 
类型的异常最明显也最容易检测，故其检测精度最高，也具有较
低的误检率。而 
TN 
类型的作为 
MI 
和噪声的混合，在某种程度上检测难度加大了，
故其检测精度没有 
MI 
的高，但是具有最低的误检率。
  
 5  
基于异常行为模式的时间序列异常检测
 
101 
 
(a)                                      (b) 
 
(c)                                      (d) 
图 
5.8
（
a
）和（
c
）是第一组项目的平均检测精度和误检率。（
b
）和（
d
）是第二组项目的平均
检测精度和误检率。其中攻击类型有三种，攻击大小比例范围为
[10%
，
100%]
。
 
Fig. 5.8 (a) and (c) are the DR and FAR of the first group; (b) and (d) are the DR and FAR of the 
second group. The number of attack types is 3. The ratio of attack size is [10%,100%]. 
 
5.4.3 SDF 
和 
X-bar 
算法有效性的比较
 
为了确保 
X-bar 
算法的有效性，使其在理想和非理想情况下都能获得正常评分
的特征，只将攻击评分注入项目生命周期的后半段。理想情况下，项目生命周期
的前半段包含的都是正常的评分（这在现实应用中很难实现）。而非理想情况下将
检查点处收集到的所有数据作为训练样本（这在现实应用中较容易实现）。
 
对于 
SDF 
来说，只需要利用收集到的评分序列对样本均值添加边界，在非理
想情况下就可以实现。
 
将理想情况下的 
X-bar 
算法，非理想情况下的 
X-bar 
算法以及 
SDF 
这三种攻击
类型的检测各重复 
10 
次，得到检测结果如图 
5.9 
所示。
SDF 
的检测精度和误检率
在理想情况下和非理想情况下的变化不大，然而 
X-bar 
算法在理想情况下的检测效
果较好。这是由于 
SDF 
中参数的确定不要求样本数据必须为正常的，而 
X-bar 
算
法在理想情况下能确定更精确的参数。因此 
X-bar 
算法的好坏大多由样本决定，而
SDF 
则不易受其影响。
 
理想情况下，
SDF 
的检测精度很接近 
X-bar 
算法，特别是对于 
MI 
攻击类型（如
图 
5.9
（
a
）所示）的检测。非理想情况下，在任何攻击类型中，
SDF 
的检测精度
优于 
X-bar 
算法的检测精度（如图 
5.9
（
a
），（
b
）和（
c
））。而任意攻击类型下，
SDF
的误检率在理想和非理想情况下的值远比 
X-bar 
算法的误检率小，如图 
5.9
（
b
），重庆大学博士学位论文 
102 
（
d
）和（
f
）所示。
 
因此现实应用中，
SDF 
能够无视样本中的错误信息，从样本中获得样本均值的
边界用于检测，取得较高的检测精度和低的误检率，而 
X-bar 
算法由于很难获得大
量的正确的样本进行学习，其检测性能并不优越。值得注意的是，在理想情况下，
SDF 
的检测精度在 
TS 
攻击类型下比较低，如（
c
）图所示。这是由于 
TS 
类型的攻
击评分会出现偏移，难以被检测到。同时 
SDF 
的检测精度随着历史真实评分数目
的增加，精度值也增加。这与事实是一致的：更多的历史数据便于判断样本均值
的边界。
 
 
 5  
基于异常行为模式的时间序列异常检测
 
103 
 
图 
5.9  
非理想情况下的检测结果与理想情况下的检测结果对比。（
a
）和（
b
）是检测精度和误
检率在 
MI 
类型攻击下的对比。（
c
）和（
d
）是检测精度和误检率在 
TS 
攻击类型下的对比。（
e
）
和（
f
）是 
TN 
类型攻击下的对比。每幅图中前两组是非理想情况下的结果，后两组是理想情
况下的结果。
 
Fig.5.9 Detection results in the non-ideal scenario versus the ideal scenario. (a) and (b) Comparisons 
of DR and FAR in maximum injection (MI), with the first two groups from the non-ideal scenario 
and the second two groups from the ideal scenario. (c) and (d) Comparisons of DR and FAR in target 
shifting (TS), with the first two groups from the non-ideal scenario and the second two groups from 
the ideal scenario. (e) and (f) Comparisons of DR and FAR in target noise (TN), with the first two 
groups from the non-ideal scenario and the second two groups from the ideal scenario. 
 
5.4.4 SDF 
和其他检测算法的鲁棒性比较
 
检测算法的鲁棒性可以从两部分进行比较：准确性和稳定性。前者在 
5.4.3 
节
中已经研究过。本节主要研究算法的稳定性。主要研究 
4 
种算法的稳定性：
SDF
，
X-bar
（理想），
X-bar
（非理想）以及 
PCA
。
 
首先向评分序列中注入攻击评分。前三种算法采用 
MI 
攻击类型。由于 
PCA
算法直接作用于用户项目的评分矩阵，故设计均值攻击评分注入到评分矩阵中。
 
定义 
5 
个连续的检查点将从每个项目的检测空间
I
D 
分出 
5 
个子空间
1 2 3 4 5
{ , , , , }
I I I I I
D D D D D
，且
I1 I2 I3 I4 I5
D 

D 

D 

D 

D
。让四种检测算法分别运行在 
5
个 子 空 间 上 （ 或 者 
5 
个 检 查 点 处 ）， 并 计 算 相 邻 子 空 间
1 2 2 3 3 4 4 5 5 1
{ , , , , , , , , , }
I I I I I I I I I I

D D 
 
D D 
 
D D 
 
D D 
 
D D 

的平均检测偏移，最终可计算
MAS 
和 
RMSS 
值，如表 
5.3 
所示。
 
由表可知，
SDF 
具有最小的 
MAS 
和 
RMSS
，这意味着 
SDF 
的检测结果随着检重庆大学博士学位论文 
104 
查点的变化产生的偏移最小。因此 
SDF 
在线检测时，维持了较高的一致性，稳定
性较好。
PCA 
排名第二，
X-bar 
排在末位。
 
对于 
SDF 
来说，尽管不同检查点的评分序列不同，包含的异常评分数目和类
型都不同，但是只要正确的对当前已知样本的样本均值边界进行了确定（只考虑
当前样本），就可以产生一致性强的检测结果。
PCA 
通过将高维数据投影到低维空
间中，选择高相似度的用户作为异常用户。由于 
PCA 
利用了评分在用户和项目两
个维度上的综合特征，产生的结果具有一定程度上的稳定性。
X-bar 
算法通过已有
的评分序列学习参数进行异常检测，因此不同检查点得到的评分序列长度不同，
相应的参数值也不同，故很容易产生不同的检测结果。相对于剩余三种检测算法，
SDF 
具有很强的稳定性。
 
 
表 
5.3  
四种检测算法的平均 
MAS 
和 
RMSS
。前三种算法检测注入攻击大小比例为 
60%
的项目，
而 
PCA 
检测注入的 
20 
个均值攻击。
 
Table.5.3 Average MAS and RMSS on four methods, 60% attack size for the first three, 20 attacks 
for PCA
 
Metric  SDF  X-Bar ideal 
X-Bar 
non-ideal 
PCA 
MAS(%)  0.18  2.53  1.29  0.89 
RMSS(%)  0.56  20.48  18.21  9.23 
 
5.4.5 SDF 
和其他检测算法的时间复杂度比较
 
基于监督的分类算法要求对训练数据进行学习，而学习的过程通常需要多次读
取存储的评分序列，故其耗时也耗存储资源。常用的无监督式聚类算法的时间复
杂度为
2
Ο(L)
。基于统计的检测算法是不同的，例如文献
[62]
中算法的时间复杂度是
Ο(Llog L)
，而 
X-bar 
的时间复杂度是
Ο(L)
。
 
SDF 
中对样本均值的边界限制的确定以及假设检验的程序在新的时间区间被
分割后能直接进行更新。因此一旦评分序列完成了动态分割，可以直接对边界进
行限制和假设检验的程序，得到检测结果。根据表 
5.1 
知，算法的复杂度为
Ο(L)
。
由于算法不需要学习，故将其应用于在线检测中消耗的时间最少。
 
5.4.6  
稳定性准则的鲁棒性检查
 
根据公式（
5.19
）和（
5.20
）进行稳定性计算的时候，由于相邻检查点收集的
序列中新增的评分最少，故只对相邻检查点之间的稳定性进行了计算。然而，当5  
基于异常行为模式的时间序列异常检测
 
105 
新增评分数目增加的时候，该稳定性准则的检测结果是否会改变呢？基于此，我
们对不相邻检查点的情况进行了验证。结果很明显，相比于相邻检查点的检测结
果，不相邻的情况会产生更高的偏移误差。更重要的问题是本章提出的稳定性准
则对算法进行检测时，产生的稳定性排序的结果是否一致。与 
5.4.4 
节类似，我们
使用相同的四种检测算法对不相邻的检查点收集到的不同长度的评分序列分别进
行 异 常 检 测 。 然 后 计 算 不 相 邻 组 之 间
1 3 2 4 3 5 4 5 5 1
{ , , , , , , , , , }
I I I I I I I I I I

D D 
 
D D 
 
D D 
 
D D 
 
D D 

的平均偏移。
 
  
其结果如表 
5.4 
所示，我们发现不同检测算法的稳定性排序和表 
5.3 
是一致的。
由于新增评分数目的增加，算法 
X-bar 
和 
PCA 
的不稳定都增加了。然而 
SDF 
的检
测结果却没有变化。由此可知算法的内在机制决定了不同检查点下算法检测结果
的稳定性。
SDF 
算法具有很强的稳定性，
PCA 
次之，而 
X-bar 
算法的稳定性最差。
 
  
综上所述，本章提出的稳定性评价准则具有鲁棒性，具体表现在不相邻检查点
的检测结果与相邻检查点的检测结果表现的算法稳定行排序是一致的。因此，公
式（
5.19
）和（
5.20
）可以作为算法稳定性计算的标准。
 
 
表 
5.4  
四种算法在不相邻检查点情况下的平均 
MAS 
和 
RMSS
。前三种算法检测注入攻击大小
比例为 
60%
的项目，而 
PCA 
检测注入的 
20 
个均值攻击。
 
Table.5.4 Average MAS and RMSS between nonadjacent checkpoints of the four methods, 60% 
attack size for the first three, 20 attacks for PCA
 
Metric  SDF  X-Bar ideal 
X-Bar 
non-ideal 
PCA 
MAS(%)  0.18  3.14  1.48  1.20 
RMSS(%)  0.56  25.29  20.71  10.93 
 
5.5  
本章小结
 
基于用户的异常行为模式提出 
SDF 
异常检测框架，通过托攻击异常评分特征
对项目的评分时间序列进行动态分割，并利用假设检验的方式判断各子区间的评
分是否异常。
 
与已有的固定时间窗口大小进行异常检测的方式不同，对评分时间序列的动态
分割的聚类过程将所有异常集中一个时间区间中，便于对类的异常检测。
SDF 
框
架可以检测大多数规模下的各种类型的异常评分，具有很好的泛化能力。同时经
过比较发现 
SDF 
具有检测精度高，误检率低，稳定性强，且时间复杂度低等优点，
特别适用于在线时间序列的异常检测。
 重庆大学博士学位论文 
106 
此外本章提出并讨论了算法的稳定性，并基于不同时间尺度下检测结果的偏移
程度，提出了稳定性的评价准则。可用于计算各类时间序列检测算法的稳定性。
 
基于上述已有工作，未来的研究方向是：
 
①
  
利用 
SDF 
检测出的异常评分区间和异常项目，对虚假用户进行检测。事实
上在异常区间内评分的用户潜在的都可以被认定为是虚假用户。所以统计用户的
异常评分数目可以初步判定其是否为虚假用户。这种判定方法也可以用于其他异
常检测中。
 
②
  
在确定了项目的异常评分区间之后，如何降低攻击带来的影响。一种有效
的方式就是通过检测的结果更新用户的可信度和项目的信誉值。系统根据可信度
和信誉值调整相似性权重，以提供更优化的决策结果。
 
③
  
对于 
TS 
类型的攻击评分，如何提高 
SDF 
的检测精度。一种可能的方式就
是结合用户和项目的其他属性（例如，登录时间，文字评论等）进行综合判断。
这也是未来研究的主要方向。
 
④
  
算法的稳定性和准确性之间的关系。尚未研究如何均衡算法检测结果的稳
定性和准确性。6  
全文总结和研究展望
 
107 
 
6  
全文总结和研究展望
 
 
6.1  
全文总结
 
本文从用户行为模式的角度，分析正常数据和异常数据的特征，结合信号处理，
模式识别中的方法，分别对流量工程中流量时间序列和推荐系统中项目的评分时
间序列进行异常检测。论文的主要成果有如下三点。
 
①基于用户正常行为模式的时间序列异常检测。
 
针对流量工程中时间序列的异常检测问题，提出流量时间序列的异常检测模型
Basis Evolution
。该模型解决了数据预处理，数据表示，自适应数据变化和异常点
分析中的典型问题，取得的成果有：
 
1)  
基于集成学习的思想，采用多种异常检测算法联合的策略对数据进行清
理，并对异常点进行修正以减少高误检率带来的信息损失。该策略简单易行，适
用于数据预处理阶段。
 
2)  
基于用户（或网络）的正常行为模式，提出基函数生成算法构建正常网络
流量空间。该算法通过生成少量的易被理解的基函数实现对正常流量的精确表示。
 
3)  
基于用户（或网络）的正常行为模式缓慢变化的特性，提出基于增量学习
的基函数演化算法，以适应动态变化的流量时间序列。与对新数据直接进行预处
理、重新生成基函数相比，基函数演化在更短的时间内实现了对新数据的表示。
 
4)  
提出对异常点聚类的策略，使管理员（或系统）只需对异常类进行分析，
而无需关注单个异常点。该策略不仅有助于对异常的分析，还减少了异常处理的
时间和资源消耗。
 
本论文提出的异常检测模型 
Basis Evolution 
可以有效检测出“变异
”
或者类型
未知的异常，实验分析表明，该方法具有更高的检测精度和更低误检率。其中误
检率可低至 
1.0
×
10
-4
，表明算法非常适用于海量数据的处理。
 
②基于趋势预测模型的时间序列异常检测。
 
基于预测的异常检测就是判断未来时间序列数据的预测值与真实值是否一致。
针对基于 
ANNs 
的预测方法在构建模型时需要大量训练时间的问题，提出基于趋
势预测模型的时间序列异常检测方法。对流量时间序列的预测中，该模型根据用
户（或网络）的正常行为模式，将对流量的预测分解为对周期趋势，相关趋势和
扰动的预测。实验表明，与通用的 
BP 
神经网络模型相比，该方法在更少的训练时
间内即可达到较高预测精度。在异常检测中，该方法能获得更高的检测精度。
 
③基于用户异常行为模式的时间序列异常检测。
 
针对推荐系统中项目的评分时间序列异常检测问题，提出异常检测模型 
SDF
。6  全
文总结与研究展望 
108 
该模型提取用户的异常行为特征，实现对时间序列的实时异常检测。此外，本文
提出了算法的稳定性评价标准。
 
1
）异常检测模型 
SDF
：
 
a.
从项目的角度对托攻击构造的虚假用户的异常行为模式进行分析得到异常
评分的行为属性和情境属性。基于这类属性提取特征可以有效区分异常评分和正
常评分。为异常项目、虚假用户的检测提供决策支持。
 
b.
基于异常评分的行为属性和情境属性，提出动态分割时间序列的算法。该算
法将异常评分聚为一类，并基于假设检验的方法判定每个类是否正常。与其他基
于项目的异常检测算法相比，该算法具有线性时间复杂度和更低的误检率，因此
可以实时地对在线时间序列数据进行异常检测。
 
2
）算法的稳定性准则。根据异常检测算法在不同时间尺度下检测结果不一致
的现象，提出算法稳定性的概念，并设计了稳定性的评价标准。与常用的异常检
测算法相比，本文提出的 
SDF 
模型稳定性最强。
 
 
6.2  
研究展望
 
时间序列广泛存在于各应用领域中，对时间序列的异常检测在各领域的决策系
统中具有重要的价值。尽管已经取得丰富的研究成果，还是有许多问题亟待解决。
综合当前已有的研究情况，思考下一步的研究方向如下：
 
①
  
本文所有的研究都是对于单变量时间序列的研究。然而现实中各类复杂的
应用产生的数据用多变量的时间序列表示更加合适方便。通常多个变量用于表示
多个属性。典型的有网络流量序列的数据不仅包含字节数，还有源 
IP 
地址，目标
IP 
地址等 
5 
个属性。因此结合模式识别的方法对多属性的时间序列数据进行处理，
提取有效特征实现异常检测是未来研究的一个重要方向。
 
②
  
本文使用的基生成和更新算法的时间复杂度很高，并不适用于实时异常检
测中。考虑利用 
Principal  pursuit 
的原则对其进行优化，使其在不丢失精度的前提
下具有更低的时间复杂度，便于实时检测。这是针对网络流量时间序列的下一步
研究内容。
 
③
  
当前常用的对海量未标记数据的处理方式是半监督学习。时间序列中，存
在大量的未标记数据，且数据的时效性很短。因此如何利用半监督学习的方式提
高对时间序列建模的性能是未来时间序列中的重要研究方向。
 
④
  
大脑视觉系统对信息处理过程的发现促进了 
ANNs 
从浅层学习向深度学习
发展。由于擅长“发现
”
数据的特征，深度学习被广泛应用于各类领域，特别是语
音和图像识别领域都取得了重大的突破。对时间序列来说，应用深度学习构造更
具有识别性的特征，分析并建模是未来关于时间序列及其应用研究的主要方向。致
     
谢
 
109 
 
致
     
谢
 
 
我的博士阶段少不了老师，朋友，亲人的陪伴。数年的博士生涯中，我经历
过不少欢喜与沮丧，奋斗与懈怠。而这些我有幸都或与老师，或与朋友，或与亲
人一起经历过，分享过，承担过。
 
在此我要感谢我的导师房斌教授。感谢老师为我答疑解惑，不断的完善本论
文；感谢老师为我指点迷津，使我在迷茫困惑的时候找到前行的道路；感谢老师
一直以来的鼓励，使我顺利的走到了今天。每一次的交谈都感受到了老师做学术
研究时候严谨务实的态度和精益求精的科研精神；老师数次从问题表面看本质的
总结让我意识到科研不应该过多在意细节，而应该关注解决问题的思路；而老师
的平易近人的性格让我感受到了学者和长者的人格魅力。
 
我要感谢我的联培外导 
Matthew Roughan 
教授。感谢教授在我初去澳洲，人生
地不熟时，对我的关怀，并提出了很多建议，使我能迅速适应当地的生活；感谢
教授对我研究上的指点和建议，使我能明确研究的方向和目标，并为之努力；感
谢教授以近乎苛刻的态度逐字修改我的论文，使我意识到自身的差距。
 
我要感谢我硕士阶段的导师李华教授。多亏您的宽容和鼓励使我能够最终确
定自己的人生规划，走上一条充满创造力，却又不失规则本质的科研之路。我要
感谢高旻师姐。师姐不仅在生活上帮助了我许多，还为我的学习和科研道路上提
供了很多极为有用的建议。师姐与我一直是亦师亦友的关系，可以说师姐是真正
带领我走向科研道路的人。感谢硕士期间的同门王根龙和邱良龙，与师姐还有你
们一起探讨问题的时光总是溜得飞快又让人满是怀念。
 
感谢模式识别研究所里的同伴们。感谢杨维斌，赵鹏，皮净锐，钱基业，吴
雪刚，刘崇文，陈琳，李凯，张廷萍，陈强与你们一起学习和讨论让我觉得受益
匪浅。
 
感谢伍玉英和邢琼香两位人生中的好姐妹，与你们拥有过最快乐的大学生活，
也愿与你们同游人生的其他旅途。
 
感谢我的父母和亲人，感谢你们夜以继日的打拼，为我和弟弟赚来安稳的生
活；感谢你们的唠唠叨叨，让我不会因为小成就而得意忘形；感谢你们的默默支
持，让我不会因为挫折而心灰意冷。无论何时，你们总能给我最坚强的后盾让我
勇敢的往前走。只愿你们能永远健康幸福。感谢马辉，一直等待我并支持我的决
定，忍受我的所有缺点，并为我人生带来快乐和安稳。感谢你的存在，让我本该
独自一人的求学路变的丰富多彩起来。
 
最后，向百忙之中还要评阅论文和参加答辩的各位专家，学者，教授表示诚
挚的敬意与谢意。
 
 
 
夏  会 
    
二 
O 
一七年五月
   
于重庆重庆大学博士学位论文 
110 
 
 参考文献 
111 
 
参考文献
 
 
[1]  V. Kotu, B. Deshpande. ‘Anomaly detection'. Predictive Analytics and Data Mining[M]. 
Elservier, 2015: 329-345. 
[2]  A. Lazarevic, L. Ertoz, V. Kumar, et al. A comparative study of anomaly detection schemes 
in network intrusion detection[C]. Proc. SIAM International Conference on Data Mining, 
2003: 25-36. 
[3]  P. Barford, D. Plonka. Characteristics of network traffic flow anomalies[C]. Proc. The 1st 
ACM SIGCOMM Workshop on Internet Measurement, 2001: 69-73. 
[4]  A. Delimargas. Iterative principal component analysis (IPCA) for network anomaly 
detection[D]. Carleton University, 2015. 
[5]  K. Xu, F. Wang, L. Gu, et al. Behavior analysis of internet traffic via bipartite graphs and 
one-mode projections[J]. IEEE/ACM Transactions on Networking, 2014, 22 (3): 931-942. 
[6]  M.H. Bhuyan, D.K. Bhattacharyya, J.K. Kalita, et al. Network anomaly detection: methods, 
systems and tools[J]. IEEE Communications Surveys and Tutorials, 2014, 16 (1): 303-336. 
[7]  P. Garca-Teodoroa, J. Daz-Verdejoa, G. Macia-Fernandeza, et al. Anomaly-based network 
intrusion detection: Techniques, systems and challenges[J]. Computers & Security, 2009, 28 
(12): 18-28. 
[8]  H. Ringberg, M. Roughan, J. Rexford, et al. The need for simulation in evaluating anomaly 
detectors[J]. Computer Communication Review, 2008, 38 (1): 55-59. 
[9]  E. Sober. The principle of parsimony[J]. The British Journal for the Philosophy of Science, 
1981, 32 (2): 145-156. 
[10]  M.H. Bhuyan, D.K. Bhattacharyyab, J.K. Kalitac. A multi-step outlier-based anomaly 
detection approach to network-wide traffic[J]. Information Sciences, 2016, 348 (243): 271. 
[11]  C. Pascoal, M.R.d. Oliveira, R. Valadas, et al. Robust feature selection and robust PCA for 
internet traffic anomaly detection[C]. Proc. International Conference on Computer 
Communications, 2012: 1755-1763. 
[12]  C. Croux, P. Filzmoser, M.R. Oliveira, et al. Algorithms for projection-pursuit robust 
principal component analysis[J]. Chemometrics and Intelligent Laboratory Systems, 2006, 87 
(2): 218-225. 
[13]  A. Lakhina, K. Papagiannaki, M. Crovella, et al. Structural analysis of network traffic 
flows[J]. Measurement and Modeling of Computer Systems, 2004, 32 (1): 61-72. 
[14]  Y. Zhang, Z. Ge, A. Greenberg, et al. Network anomography[C]. Proc. The 5th ACM 重庆大学博士学位论文 
112 
SIGCOMM Conference on Internet Measurement, 2005.  
[15]  P. Barford, J. Kline, D. Plonka, et al. A signal analysis of network traffic anomalies[C]. Proc. 
ACM SIGCOMM Workshop on Internet Measurement, 2002: 71-82. 
[16]  A. Lakhina, M. Crovella, C. Diot, et al. Diagnosing network-wide traffic anomalies[J]. ACM 
Special Interest Group on Data Communication, 2004, 34 (4): 219-230. 
[17]  B. Eriksson, P. Barford, R. Bowden, et al. Basisdetect: a model-based network event 
detection framework[C]. Proc. The 10th ACM SIGCOMM Conference on Internet 
Measurement, 2010: 451-464. 
[18]  H. Ringberg, A. Soule, J. Rexford, et al. Sensitivity of PCA for traffic anomaly detection[J]. 
Measurement and Modeling of Computer Systems, 2007, 35 (1): 109-120. 
[19]  J.L. Bali, G. Boente, D.E. Tyler, et al. Robust functional principal components: a 
projection-pursuit approach[J]. Annals of Statistics, 2012, 39 (6): 2852-2882. 
[20]  A. Delimargas, E. Skevakis, H. Halabian, et al. IPCA for network anomaly detection[C]. 
Proc. Cyber Security and Trusted Computing, 2015. 
[21]  Y. Chen, B. Yang, Q. Meng, et al. Small-time scale network traffic prediction based on 
flexible neural tree[J]. Applied Soft Computing, 2012, 12 (1): 274-279. 
[22]  T. Otoshi, Y. Ohsita, M. Murata, et al. Traffic engineering based on model predictive 
control[J]. IEICE Transactions on Communications, 2015, 98 (6): 996-1007. 
[23]  M. Joshi, T.H. Hadi. A review of network traffic analysis and prediction techniques[J]. Co RR, 
2015. 
[24]  S. Basu, A. Mukherjee, S. Klivansky. Time series models for internet traffic[C]. Proc. Local 
Computer Networks, 1999. 
[25]  G.E.P. Box, G.M. Jenkins, G.C. Reinsel, et al. Time series analysis: forecasting and 
control[M]. John Wiley & Sons. 2015. 
[26]  N.K. Groschwitz, G.C. Polyzos. A time series model of long-term NSFNET backbone 
traffic[J]. IEEE International Conference on Communications, 1994: 1400-1404. 
[27]  C.G. Looney. Pattern recognition using neural networks: theory and algorithms for engineers 
and scientists[M]. Oxford University Press. 1997. 
[28]  K. Papagiannaki, N. Taft, Z.L. Zhang, et al. Long-term forecasting of internet backbone 
traffic: observations and initial models[C]. Proc. IEEE International Conference on Computer 
Communications, 2003: 1178-1188. 
[29]  R.H. Riedi, M.S. Crouse, V.J. Ribeiro, et al. A multifractal wavelet model with application to 
network traffic[J]. IEEE Transactions on Information Theory, 1999, 45 (3): 992-1018. 
[30]  B.B. Mandelbrot. Self-similar error clusters in communication systems and the concept of 参考文献 
113 
conditional stationarity[J]. IEEE Transactions on Communications, 1965, 13 (1): 71-90. 
[31]  J. Zou, F. Fekri. A belief propagation approach for detecting shilling attacks in collaborative 
filtering[C]. Proc. The 22nd ACM International Conference on Information & Knowledge 
Management, 2013: 1837-1840. 
[32]  L. Zhu, L. Qin, K. Xue, et al. A novel bp neural network model for traffic prediction of next 
generation network[C]. Proc. The 5th International Conference on Natural Computation, 
2009: 32-38. 
[33]  L. Xiang, X. Ge, C. Liu, et al. A new hybrid network traffic prediction method[C]. Proc. 
IEEE Global Communication Conference, 2015: 1-5. 
[34]  D. Park. Structure optimization of bi Linear recurrent neural networks and its application to 
Ethernet network traffic prediction[J]. Information Sciences, 2013, 237: 18-28. 
[35]  C. Ren, C. Wang, C. Yin, et al. The prediction of short-term traffic flow based on the niche 
genetic algorithm and bp neural network[C]. Proc. International Conference on Information 
Technology and Software Engineering, 2013: 775-781. 
[36]  L. Wang, B. Yang, Y. Chen, et al. Modeling early-age hydration kinetics of Portland cement 
using flexible neural tree[J]. Neural Computing and Applications, 2012, 21 (5): 877-889. 
[37]  A. Edmunds, A. Morris. The problem of information overload in business organisations: a 
review of the literature[J]. International Journal of Information Management, 2000, 20 (1): 
17-28. 
[38]  T.A. G. Adomavicius. Toward the next generation of recommender systems: a survey of the 
state-of-the-art and possible extensions[J]. IEEE Transactions on Knowledge and Data 
Engineering, 2005, 17 (6): 734-749. 
[39]  M. Gao, K.C. Liu, Z.F. Wu, et al. Personalisation in web computing and informatics: 
Theories, techniques, applications, and future research[J]. Information Systems Frontiers, 
2010, 12 (5): 607-629. 
[40]  J.A. Konstan, B.N. Miller, D. Maltz, et al. Group Lens: applying collaborative filtering to 
Usenet news[J]. Communications of The ACM, 1997, 40 (3): 77-87. 
[41]  B. Mobasher, R. Burke, R. Bhaumik, et al. Toward trustworthy recommender systems: An 
analysis of attack models and algorithm robustness[J]. ACM Transactions on Internet 
Technology, 2007, 7 (4). 
[42]  M.P. O’Mahony, N.J. Hurley, G.C.M. Silvestre, et al. Promoting recommendations: an attack 
on collaborative filtering[J]. database and expert systems applications, 2002: 494-503. 
[43]  M.P.O. Mahony, N. J. Hurley, G.C.M. Silvestre, et al. Towards robust collaborative 
filtering[J]. Lecture Notes in Computer Science, 2002: 87-94. 重庆大学博士学位论文 
114 
[44]  I. Gunes, C. Kaleli, A. Bilge, et al. Shilling attacks against recommender systems: a 
comprehensive survey[J]. Artificial Intelligence Review, 2014, 42 (4): 767-799. 
[45]  R. Bhaumik, B. Mobasher, R. Burke. A clustering approach to unsupervised attack detection 
in collaborative recommender systems[C]. Proc. The 7th IEEE International Conference on 
Data Mining, 2011: 181-187. 
[46]  B. Mehta, W. Nejdl. Unsupervised strategies for shilling detection and robust collaborative 
filtering[J]. User Modeling and User-adapted Interaction, 2009, 19 (1). 
[47]  Z.P. Cheng, N. Hurley. Effective diverse and obfuscated attacks on model-based 
recommender systems[C]. Proc. The 3rd ACM Conference on Recommender Systems, 2009: 
141-148. 
[48]  C. Williams, B. Mobasher, R. Burke, et al. Detection of obfuscated attacks in collaborative 
recommender systems[C]. Proc. The ECAI Workshop on Recommender Systems, 2006: 94. 
[49]  N.J. Hurley, Z.P. Cheng, M. Zhang, et al. Statistical attack detection[C]. Proc. The 3rd ACM 
Internaional Conference Recommender Systems, 2009: 149-156. 
[50]  Y. Kim, R. Phalak. A trust prediction framework in rating-based experience sharing social 
networks without a Web of Trust[J]. Information Sciences, 2012: 128-145. 
[51]  W.T. Teacy, M. Luck, A. Rogers, et al. An efficient and versatile approach to trust and 
reputation using hierarchical Bayesian modelling[J]. Artificial Intelligence, 2012: 149-185. 
[52]  G. Vogiatzis, I. Mac Gillivray, M. Chli. A probabilistic model for trust and reputation[J]. in 
IEEE International Symposium on Information Theory, 2011: 2173-2177. 
[53]  E. Ayday, F. Fekri. Application of belief propagation to trust and reputation management[C]. 
Proc. The International Symposium on Information Theory, 2011: 2173-2177. 
[54]  E. Ayday, F. Fekri. Iterative trust and reputation management using belief propagation[J]. 
IEEE Transactions on Dependable and Secure Computing, 2012, 9 (3): 375-386. 
[55]  R. Burke, B. Mobasher, C. Williams, et al. Classification features for attack detection in 
collaborative recommender systems[C]. Proc. The 12th ACM SIGKDD Internationla 
Conference on Knowledge Discovery and Data Mining, 2006: 542-547. 
[56]  J. Cao, Z. Wu, B. Mao, et al. Shilling attack detection utilizing semi-supervised learning 
method for collaborative recommender system[J]. World Wide Web, 2013, 16: 729-748. 
[57]  Z. Wu, J.J. Wu, J. Cao, et al. A semi-supervised hybrid shilling attack detector for 
trustworthy product recommendation[C]. Proc. The 18th ACM SIGKDD International 
Conference on Knowledge Discovery and Data Mining, 2012: 985-993. 
[58]  S.S.H.S.-W. Kim. Unsupervised detection of obfuscated diverse attacks in recommender 
systems[C]. Proc. Research in Adaptive and Convergent Systems, 2014: 40-45. 参考文献 
115 
[59]  Z. Zhang, S.R. Kulkarni. Graph-based detection of shilling attacks in recommender 
systems[C]. Proc. IEEE International Workshop on Machine Learning for Signal Processing, 
2013. 
[60]  J.S. Lee, D. Zhu. Shilling Attack Detection—A New Approach for a Trustworthy 
Recommender System[J]. Informs Journal on Computing, 2011, 24 (1): 117-131. 
[61]  R. Bhaumik, C. Williams, B. Mobasher, et al. Securing collaborative filtering against 
malicious attacks through anomaly detection[C]. Proc. The 4th Workshop on Intelligent 
Techniques for Web Personalization, 2006. 
[62]  S. Zhang, A. Chakrabarti, J. Ford, et al. Attack detection in time series for recommender 
systems[C]. Proc. The 20th ACMSIGKDD International Conference on Knowledge 
Discovery and Data Mining, 2006: 809-814. 
[63]  M. Gao, Q. Yuan, B. Ling, et al. Detection of Abnormal Item Based on Time Intervals for 
Recommender Systems[J]. The Scientific World Journal, 2014, 2014 (2014). 
[64]  W. Zhou, J. Wen, Y.S. Koh, et al. Shilling attacks detection in recommender systems based 
on target item analysis[J]. PLOS ONE, 2015, 10 (7). 
[65]  Y. Athavale, S. Krishnan, P. Hosseinizadeh, et al. Identifying the potential for failure of 
businesses in the technology, pharmaceutical and banking sectors using kernel-based 
machine learning methods[C]. Proc. IEEE Conference on Systems, Man and Cybernetics, 
2009: 1073-1077. 
[66]  
陈希孺
.  
概率论与数理统计
[M].  
中国科学技术大学出版社
. 2009. 
[67]  D. Zheng, F. Li, T. Zhao. Self-adaptive statistical process control for anomaly detection in 
time series[J]. Expert Systems With Applications, 2016, 57: 324-336. 
[68]  G.F. Piepel. Robust regression and outlier detection[J]. Technometrics, 2012, 31 (2): 260-261. 
[69]  D. Chen, X.G. Shao, H.U. Bin. Simultaneous wavelength selection and outlier detection in 
multivariate regression of near-infrared spectra[J]. Analytical Sciences, 2005, 21 (2): 
161-166. 
[70]  B. Abraham, G.E.P. Box. Bayesian analysis of some outlier problems in time series[J]. 
Biometrika, 1979, 66 (2): 229-236. 
[71]  E. Eskin. Anomaly detection over noisy data using learned probability distributions[C]. Proc. 
The 17th International Conference on Machine Learning, 2000: 255-262. 
[72]  A.R. Webb, K.D. Copsey. Statistical Pattern recognition[M]. John Wiley & Sons. 2011. 
[73]  G.J. Mc Lachlan, D. Peel. Finite mixture models[M]. John Wiley & Sons. 2000. 
[74]  H. Zhou, D. Zhang, K. Xie. Accurate traffic matrix completion based on multi-Gaussian 
models[J]. Computer Communications, 2017, 102: 165-176. 重庆大学博士学位论文 
116 
[75]  E. Parzen. On estimation of a probability density function and mode[J]. Annals of 
Mathematical Statistics, 1962, 33 (3): 1065-1076. 
[76]  D.J. Berndt, J. Clifford. Using dynamic time warping to find patterns in time series[C]. Proc. 
The 3rd International Conference on Knowledge Discovery and Data Mining, 1994: 359-370. 
[77]  L. Breiman, W. Meisel, E. Purcell. Variable kernel estimates of multivariate densities[J]. 
Technometrics, 2012, 19 (2): 135-144. 
[78]  Z. Zhang, R. Tavenard, A. Bailly, et al. Thomas Corpetti.Dynamic Time Warping under 
limited warping path length[J]. Information Sciences, 2017, 393: 91-107. 
[79]  J. Zhang, H. Wang. Detecting outlying subspaces for high-dimensional data: the new task, 
algorithms, and performance[J]. Knowledge and Information Systems, 2006, 10 (3): 
333-355. 
[80]  E.M. Knorr, R.T. Ng, V. Tucakov. Distance-based outliers: algorithms and applications[J]. 
The International Journal on Very Large Data Bases, 2000: 237-253. 
[81]  S. Bay, M. Schwabacher. Mining distance-based outliers in near linear time with 
randomization and a simple pruning rule[C]. Proc. The 9th ACM SIGKDD International 
Conference on Knowledge Discovery and Data Mining, 2003: 29-38. 
[82]  M.M. Breuning, H. Kriegel, R.T. Ng, et al. LOF: identifying density-based local outliers[C]. 
Proc. ACM SIGMOD International Conference on Management of Data, 2000: 93-104. 
[83]  M. Bai, X. Wang, J. Xin, et al. An efficient algorithm for distributed density-based outlier 
detection on big data[J]. Neurocomputing, 2016 181 19-28. 
[84]  J.W. Han, M. Kamber, J. Pei. Data mining concepts and techniques (3rd Edition)[M]. 
Elservier. 2012. 
[85]  L. Ertz, M. Steinbach, V. Kumar. Finding topics in collections of documents: a shared nearest 
neighbor approach[C]. Proc. The 1st SIAM International Conference on Data Mining, 2001. 
[86]  A. Diez-Olivan, J.A. Pagan, R. Sanz, et al. Data-driven prognostics using a combination of 
constrained K-means clustering, fuzzy modeling and LOF-based score[J]. Neurocomputing, 
2017, 241: 97-107. 
[87]  A. Karamia, M. Guerrero-Zapata. A fuzzy anomaly detection system based on hybrid 
PSO-Kmeans algorithm in content-centric networks[J]. Neurocomputing, 2015 149 
1253–1269. 
[88]  J.R. Quinlan. Induction of decision trees[J]. Machine Learning, 1986, 1 (1): 81-106. 
[89]  J.R. Quinlan. C4.5: Programs for Machine Learning[M]. Morgan Kaufmann Publishers. 
1993. 
[90]  A.D. Gordon, L. Breiman, J.H. Friedman, et al. Classification and regression trees[J]. Journal 参考文献 
117 
of the American Statistical Association, 1986, 81 (393). 
[91]  W.W. Cohen. Fast effective rule induction[C]. Proc. The 12th International Conference on 
Machine Learning, 1995. 
[92]  J.W. Grzymalabusse, Y.Y. Yao. Probabilistic rule induction with the LERS data mining 
system[J]. International Journal of Intelligent Systems, 2011, 26 (6): 518-539. 
[93]  S. Tsumoto, S. Hirano. Probabilistic rule induction based on incremental sampling scheme[C]. 
Proc. IEEE International Conference on Granular Computing, 2014: 304-309. 
[94]  M.D. Ruiz, M.J. Martinbautista, D. Sanchez, et al. Anomaly detection using fuzzy 
association rules[J]. International Journal of Electronic Security and Digital Forensics, 2014, 
6(1): 25-37. 
[95]  Z.Y. He, X.F. Xu, Z.X. Huang, et al. A Frequent Pattern Discovery Method for Outlier 
Detection[J]. Web Age Information Management, 2004: 726-732. 
[96]  V. Vapnik. The nature of statistical learning theory[J]. Technometrics, 2012, 38 (4): 409. 
[97]  V.N. Vapnik. Statistical learning theory[M]. John Wiley &Sons. 1998. 
[98]  
常甜甜
.  
支持向量机学习算法若干问题的研究
[D].  
西安电子科技大学
, 2010. 
[99]  K. Yan, Z. Ji, W. Shen. Online fault detection methods for chillers combining extended 
kalman filter and recursive one-class SVM[J]. Neurocomputing, 2017, 228: 205-212. 
[100]  T.M. Mitchell. Machine learning[M]. 2003. 
[101]  Y.R. Zeng, Y. Zeng, B. Choi, et al. Multifactor-influenced energy consumption forecasting 
using enhanced back-propagation neural network[J]. Energy, 2017, 127:381-396. 
[102]  G. INOUSSA.  
基于改进的神经网络自回归模型的非线性时间序列建模和预测
[D].  
中南
大学
, 2012. 
[103]  X. Yu, S. Xiong, Y. He, et al. Research on campus traffic congestion detection using BP 
neural network and Markov model[J]. Information Security and Applications, 2016, 31: 
54-60. 
[104]  F. Gaxiola, P. Melin, F. Valdez, et al. Generalized type-2 fuzzy weight adjustment for 
backpropagation neural networks in time series prediction[J]. Information Sciences, 2015, 
325: 159-174. 
[105]  H.W. Coppock, J. Freund. All-or-none versus incremental learning of errorless shock escapes 
by the rat[J]. Science, 1962, 135 (3500): 318-319. 
[106]  Y. Liu, Q. He, Q. Chen. Incremental batch learning with support vector machines[C]. Proc. 
The 5th World Congress on Intelligent Control and Automation, 2004: 1857–1861. 
[107]  W.J. Wang. A redundant incremental learning algorithm for SVM[C]. Proc. The Seventh 
International Conference on Machine Learning and Cybernetics 2008: 734–738. 重庆大学博士学位论文 
118 
[108]  R. Chitrakar, C. Huang. Selection of Candidate Support Vectors in incremental SVM for 
network intrusion detection[J]. Computers & Security, 2014, 45: 231–241. 
[109]  G.H. Golub, C.F.V. Loan. Matrix Computations[M]. JHU Press. 2012. 
[110]  B. Sarwar, G. Karypis, J. Konstan, et al. Incremental singular value decomposition 
algorithms for highly scalable recommender systems[C]. Proc. The 5th International 
Conference on Computer and Information Technology, 2002. 
[111]  X. Zhoua, J. He, G. Huang, et al. SVD-based incremental approaches for recommender 
systems[J]. Journal of Computer and System Sciences, 2015, 81 (4): 717–733. 
[112]  B.N. Li, D. Yao, Y.K. Qian. Incremental principal component analysis method on online 
network anomaly detection[C]. Proc. International Conference on Information and Network 
Security, 2013: 28. 
[113]  N.C. Oza. Online bagging and boosting[C]. Proc. IEEE International Conference on Systems, 
Man and Cybernetics, 2005: 2340-2345. 
[114]  N. Tajbakhsh, H. Wu, W. Xue, et al. A novel online boosting algorithm for automatic 
anatomy detection[J]. machine vision applications, 2012, 24(7): 1359-1370. 
[115]  Z.Q. Qi, Y.T. Xu, L.X. Wang, et al. Online multiple instance boosting for object detection[J]. 
Neurocomputing, 2011, 74 (10): 1769-1775. 
[116]  G. Magna, P. Casti, S. Velappa, et al. Identification of mammography anomalies for breast 
cancer detection by an ensemble of classification models based on artificial immune 
system[J]. Knowledge-Based Systems, 2016, 101: 60–70. 
[117]  A. Theissler. Detecting known and unknown faults in automotive systems using 
ensemble-based anomaly detection[J]. Knowledge-Based Systems, 2017, 123: 163–173. 
[118]  A.A. Aburomman, M.B.I. Reaz. A novel SVM-k NN-PSO ensemble method for intrusion 
detection system[J]. Applied Soft Computing, 2016, 38: 360–372. 
[119]  R.A. Sadek. SVD based image processing applications: state of the art, contributions and 
research challenges[J]. International Journal of Advanced Computer Science and 
Applications, 2012, 3 (7). 
[120]  M.G. Vozalis, K.G. Margaritis. Using SVD and demographic data for the enhancement of 
generalized Collaborative Filtering[J]. Information Sciences, 2007, 177(15): 3017-3037. 
[121]  M. Roughan, A. Greenberg, C. Kalmanek, et al. Experience in measuring backbone traffic 
variability: models,metrics, measurements and meaning[C]. Proc. The 2nd ACM SIGCOMM 
Workshop on Internet Measurement, 2002: 91-92. 
[122]  D.D. Lee, H.S. Seung. Algorithms for non-negative matrix factorization[C]. Proc. Advances 
in Neural Information Processing Systems, 2001: 556-562. 参考文献 
119 
[123]  R. Peharz, F. Pernkopf. Sparse nonnegative matrix factorization with l0 -constraints[J]. 
Neurocomputing, 2012, 80 (1): 38-46. 
[124]  M. Roughan, J. Gottlieb. Large-scale measurement   and modeling of back-bone internet 
traffic[C]. Proc. The International Society for Optical   Engineering, 2002. 
[125]  M. Roughan. On the beneficial impact of strong   correlations for anomaly detection[J]. 
Stochastic Models, 2009, 25 (1): 1-27. 
[126]  Y. Zhao, G. Karypis, D.Z. Du. Criterion   functions for document clustering: Experiments 
and   analysis[R]. Book Criterion   functions for document clustering: Experiments and 
analysis, 2001.  
[127]  T. Fawcett. An introduction to ROC analysis[J]. Pattern Recognition Letters, 2006, 27 (8): 
861-874. 
[128]  P. Tune, K. Cho, M. Roughan. A comparison of information criteria for traffic model 
selection[C]. Proc. The 10th International Conference on Signal Processing and 
Communications Systems, 2016. 
[129]  D.E. Rumelhart, G.E. Hinton, R.J. Williams, et al. Learning representations by 
back-propagating errors[J]. Nature, 1986, 323 (6088): 533-536. 
[130]  G. Wei. Application of Entropy to the Pruning Algorithm of BP Neural Network[J]. 
Information & Computation, 2009. 
[131]  F.L. Chung, T.T. Lee. A node pruning algorithm for backpropagation networks[J]. 
International Journal of Neural Systems, 2011, 03 (03): 301-314. 
[132]  I. Jordanov, A. Georgieva Neural. Network learning with global heuristic search[J]. IEEE 
Transactions on Neural Networks, 2007, 18 (3): 937-942. 
[133]  R.M.D. Jong, N. Sakarya. The econometrics of the Hodrick-Prescott filter[J]. The Review of 
Economics and Statistics, 2016. 
[134]  R.G. King, S. Rebelo. Low frequency filtering and real business cycles[J]. Journal of 
Economic Dynamics and Control, 1993: 207-231. 
[135]  T.M. Pedersen. The Hodrick-Prescott filter, the slutzky effect, and the distortionary effect of 
filters[J]. Journal of Economic Dynamics and Control, 2001, 25 (8): 1081-1101. 
[136]  R. Weron, M. Zator. A note on using the Hodrick-Prescott filter in electricity markets[J]. 
Energy Economics, 2015: 1-6. 
[137]  A. Saha, V. Sindhwani. Learning evolving and emerging topics in social media: a dynamic 
nmf approach with temporal regularization[C]. Proc. Web Search and Data Mining, 2012: 
693-702. 
[138]  S. Kim, K. Koh, S. Boyd, et al. L1 trend filtering[J]. Siam Review, 2009, 51 (2): 339-360. 重庆大学博士学位论文 
120 
[139]  E.J. Candes, M.B. Wakin, S. Boyd, et al. Enhancing sparsity by reweighted L1 
minimization[J]. Journal of Fourier Analysis and Applications, 2007, 14 (5): 877-905. 
[140]  L. Sayfullina, M. Westerlund, K. Bjork, et al. HP trend filtering using Gaussian mixture 
model weighted heuristic[C]. Proc. IEEE International Conference on Tools With Artificial 
Intelligence, 2014: 989-996. 
[141]  http://noc.net.internet2.edu/. 
[142]  S. Sarvotham,R.H. Riedi, R.G. Baraniuk, et al. Network and user driven alpha-beta on-off 
source model for network traffic[J]. Computer Networks, 2005, 48(3): 335-350. 
[143]  https://en.wikipedia.org/wiki/Skewness, accessed  
[144]  G. Adomavicius, J.J. Zhang. Stability of recommendation algorithms[J]. ACM Transactions 
on Information Systems, 2012, 30 (4). 
[145]  M.P.O. Mahony, N.J. Hurley, N. Kushmerick, et al. Collaborative recommendation: a 
robustness analysis[J]. ACM Transactions on Internet Technology, 2004, 4 (4): 344-377. 
[146]  N. Hu, P.A. Pavlou, J. Zhang. Why do online product reviews have a J-shaped distribution? 
Overcoming biases in online word-of-mouth communication[J]. Marketing Science, 2007, 
198 (7). 
[147]  L.L. Wei, J.H. Ma, R.F. Yan. An introduction to probability and statistics[M]. Science press. 
2012. 
[148]  L.Ott, M.T. Longnecker. An introduction to statistical methods and data analysis[M]. Nelson 
Education. 2015. 
[149]  https://grouplens.org/datasets/movielens/.
 附 
    录
 
121 
 
附
     
录
 
 
A
．攻读博士期间发表的论文
 
[1]  Hui  Xia,  Bin  Fang,  Min  Gao,  Hui  Ma,  Yuanyan  Tang,  "A  Novel  Item  Anomaly  Detection 
Approach against Shilling Attacks in Collaborative Recommendation System using Dynamic 
Time Interval Segmentation Technique". INFORMATION SCIENCES, Vol. 306, pp 150-165, 
10 June 2015.
（
SCI
）
 
[2]  Jiang  Feng,  Min  Gao,  Hui  Xia,  Qingyu  Xiong  and  Junhao  Wen,"A  Evaluation  Approach 
based  on  Word-of-mouth  for  Trust  Models  in  Recommendation  System".  COMPUTER 
MODELLING AND NEW TECHNOLOGIES, Vol. 18, pp. 605-609, 2014. (EI) 
[3]  Hua Li, Hui Xia, Min Gao, Hui Ma, "Study on Reputation Model of E-commerce Networks", 
AISS, Vol. 5, No. 10, pp. 1-10, 2013. 
[4]  Hui  Xia,  Bin  Fang,  Matthew  Roughan,  Kenjiro  Cho,  Paul  Yune“A  Basis Evolution 
framework for network traffic anomaly detection”, submitted to COMPUTER NETWORKS 
(SCI). (under review) 
[5]  Hui  Xia,  Bin  Fang,  Matthew  Roughan,  Lin  Chen,  Chongwen  Liu,  Wensheng  Chen,  "An 
Trend Filtering based Prediction Framework of Network Traffic Flow ", submitted to IEICE 
TRANSACTIONS ON COMMUNICATION (SCI). (under review) 
 
B
．申请的专利
 
[1]  基
于流量趋势的网络流量预测方法；房斌，夏会，李凯，陈琳，刘崇文；2
01510793377.1 
 
C
．攻读博士期间参与的项目
 
[1]  
参 与 国 家 
“973” 
重 点 基 础 研 究 发 展 计 划 课 题 “ 智 慧 协 同 网 络 基 础 研 究 ”
（
No.2013CB329100
）子课题
“
资源动态适配机制与理论
”
（
No. 2013CB329103
）
. 
[2]  
参与国家自然科学基金项目“基于用户可信度的抗托攻击协同过滤推荐机理研究”（
No.
 
71102065
）
. 